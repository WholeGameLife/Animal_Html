<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç”µå­ç›†æ ½ - æˆ˜æ–—åœºæ™¯</title>
    <!-- å¼•å…¥ Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            background-color: #111827;
            color: #f3f4f6;
            font-family: 'Inter', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
        }

        .battle-container {
            width: 100%;
            max-width: 1200px;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 2rem;
        }

        .battle-arena {
            display: flex;
            justify-content: space-around;
            align-items: center;
            flex-grow: 1;
            position: relative;
        }

        .animal-card {
            background: rgba(31, 41, 55, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid #4b5563;
            border-radius: 1rem;
            padding: 1.5rem;
            width: 300px;
            text-align: center;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
            transition: transform 0.3s ease;
        }

        /* æ”»å‡»æŠ–åŠ¨æ•ˆæœ */
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
            20%, 40%, 60%, 80% { transform: translateX(5px); }
        }
        .animate-shake {
            animation: shake 0.3s ease-in-out;
        }

        /* é˜²å¾¡å‘å…‰æ•ˆæœ */
        @keyframes defend-glow {
            0%, 100% { box-shadow: 0 0 10px rgba(59, 130, 246, 0.5); }
            50% { box-shadow: 0 0 30px rgba(59, 130, 246, 1); }
        }
        .animate-defend {
            animation: defend-glow 0.5s ease-in-out;
            border-color: #3b82f6 !important;
        }

        /* æŠ€èƒ½æ¿€æ´»æ•ˆæœ */
        @keyframes skill-activate {
            0% { transform: scale(1); box-shadow: 0 0 0 rgba(167, 139, 250, 0); }
            50% { transform: scale(1.1); box-shadow: 0 0 25px rgba(167, 139, 250, 1); }
            100% { transform: scale(1); box-shadow: 0 0 0 rgba(167, 139, 250, 0); }
        }
        .skill-triggered {
            animation: skill-activate 0.6s ease-in-out;
            border-color: #a78bfa !important;
            border-width: 3px !important;
            background: linear-gradient(135deg, rgba(167, 139, 250, 0.6) 0%, rgba(236, 72, 153, 0.6) 100%) !important;
        }
        
        /* æŒç»­ç”Ÿæ•ˆçš„æŠ€èƒ½é«˜äº® */
        @keyframes skill-active-glow {
            0%, 100% { box-shadow: 0 0 10px rgba(34, 197, 94, 0.6); }
            50% { box-shadow: 0 0 20px rgba(34, 197, 94, 1); }
        }
        .skill-active {
            animation: skill-active-glow 1.5s ease-in-out infinite;
            border-color: #22c55e !important;
            border-width: 3px !important;
            background: linear-gradient(135deg, rgba(34, 197, 94, 0.4) 0%, rgba(16, 185, 129, 0.4) 100%) !important;
        }

        .animal-card:hover {
            transform: translateY(-10px);
        }

        .animal-avatar {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            margin: 0 auto 1rem;
            border: 4px solid;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2rem;
            font-weight: bold;
        }

        .health-bar-container {
            background-color: #4b5563;
            border-radius: 9999px;
            height: 1rem;
            width: 100%;
            margin-top: 0.5rem;
            overflow: hidden;
        }

        .health-bar {
            background-color: #22c55e;
            height: 100%;
            border-radius: 9999px;
            transition: width 0.5s ease-in-out;
        }

        .opponent .animal-avatar {
            border-color: #ef4444;
        }

        .player .animal-avatar {
            border-color: #3b82f6;
        }

        .action-panel {
            background: rgba(17, 24, 39, 0.9);
            padding: 1rem;
            border-radius: 1rem;
            border-top: 1px solid #374151;
            display: flex;
            justify-content: center;
            gap: 1rem;
        }

        .action-button {
            background-color: #3b82f6;
            color: white;
            font-weight: bold;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            border: none;
            cursor: pointer;
            transition: background-color 0.2s;
            min-width: 120px;
        }

        .action-button:hover:not(:disabled) {
            background-color: #2563eb;
        }

        .action-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .flee-button {
            background-color: #6b7280;
        }

        .flee-button:hover {
            background-color: #4b5563;
        }

        .vs-text {
            font-size: 4rem;
            font-weight: bold;
            color: #ef4444;
            text-shadow: 0 0 15px #ef4444;
        }

        .return-button {
            background-color: #22c55e;
            color: white;
            font-weight: bold;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            border: none;
            cursor: pointer;
            transition: background-color 0.2s;
            min-width: 240px;
        }

        /* å›åˆæŒ‡ç¤ºå™¨ */
        .turn-indicator {
            position: absolute;
            top: -2rem;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(59, 130, 246, 0.9);
            color: white;
            padding: 0.5rem 1.5rem;
            border-radius: 9999px;
            font-weight: bold;
            font-size: 0.875rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }
    </style>
</head>
<body>

    <div class="battle-container">
        <!-- æˆ˜æ–—æ—¥å¿— (é¡¶éƒ¨) - æ»šåŠ¨æ—¥å¿—é¢æ¿ -->
        <div class="bg-gray-900/80 rounded-lg border border-gray-700 mb-4" style="height: 150px; overflow-y: auto;">
            <div id="battle-log" class="text-sm space-y-1 font-mono p-4">
                <div class="text-yellow-300">âš”ï¸ æˆ˜æ–—å‡†å¤‡ä¸­...</div>
            </div>
        </div>

        <!-- æˆ˜æ–—åŒºåŸŸ -->
        <div class="battle-arena">
            <!-- æˆ‘æ–¹åŠ¨ç‰© -->
            <div id="player-card" class="animal-card player" style="position: relative;">
                <div id="player-turn-indicator" class="turn-indicator" style="display: none;">æˆ‘çš„å›åˆ</div>
                <div id="player-avatar" class="animal-avatar"></div>
                <h2 id="player-name" class="text-2xl font-bold">ç©å®¶åŠ¨ç‰©</h2>
                <p id="player-level" class="text-sm text-gray-400">Lv. 1</p>
                <div class="health-bar-container">
                    <div id="player-health-bar" class="health-bar"></div>
                </div>
                <p id="player-health-text" class="text-xs mt-1">100 / 100</p>
                <div class="mt-2 text-xs text-gray-400">
                    <span>âš”ï¸ <span id="player-atk">10</span></span>
                    <span class="ml-2">ğŸ›¡ï¸ <span id="player-def">5</span></span>
                    <span class="ml-2">âš¡ <span id="player-agi">8</span></span>
                </div>
                
                <!-- æŠ€èƒ½æ§½æ˜¾ç¤º -->
                <div class="mt-3 pt-3 border-t border-gray-600">
                    <p class="text-xs text-gray-400 mb-2">è£…å¤‡æŠ€èƒ½</p>
                    <div id="player-skill-slots" class="grid grid-cols-2 gap-2">
                        <!-- åŠ¨æ€ç”Ÿæˆ -->
                    </div>
                </div>
            </div>

            <div class="vs-text">VS</div>

            <!-- æ•Œæ–¹åŠ¨ç‰© -->
            <div id="opponent-card" class="animal-card opponent" style="position: relative;">
                <div id="opponent-turn-indicator" class="turn-indicator" style="display: none;">æ•Œæ–¹å›åˆ</div>
                <div id="opponent-avatar" class="animal-avatar"></div>
                <h2 id="opponent-name" class="text-2xl font-bold">é‡ç”ŸåŠ¨ç‰©</h2>
                <p id="opponent-level" class="text-sm text-gray-400">Lv. 1</p>
                <div class="health-bar-container">
                    <div id="opponent-health-bar" class="health-bar bg-red-500"></div>
                </div>
                <p id="opponent-health-text" class="text-xs mt-1">100 / 100</p>
                <div class="mt-2 text-xs text-gray-400">
                    <span>âš”ï¸ <span id="opponent-atk">10</span></span>
                    <span class="ml-2">ğŸ›¡ï¸ <span id="opponent-def">5</span></span>
                    <span class="ml-2">âš¡ <span id="opponent-agi">8</span></span>
                </div>
                
                <!-- æŠ€èƒ½æ§½æ˜¾ç¤º -->
                <div class="mt-3 pt-3 border-t border-gray-600">
                    <p class="text-xs text-gray-400 mb-2">è£…å¤‡æŠ€èƒ½</p>
                    <div id="opponent-skill-slots" class="grid grid-cols-2 gap-2">
                        <!-- åŠ¨æ€ç”Ÿæˆ -->
                    </div>
                </div>
            </div>
        </div>

        <!-- æ“ä½œé¢æ¿ -->
        <div class="action-panel">
            <button id="btn-start-battle" class="action-button bg-green-600 hover:bg-green-700">å¼€å§‹è‡ªåŠ¨æˆ˜æ–—</button>
            <button id="btn-flee" class="action-button flee-button">é€ƒè·‘</button>
        </div>
    </div>

    <script>
        // æˆ˜æ–—æŠ€èƒ½é…ç½® (ä» animal_management.html å¤åˆ¶)
        const COMBAT_SKILLS = {
            'POWER_STRIKE': { name: 'åŠ›é‡æ‰“å‡»', icon: 'ğŸ’¥', type: 'attack', desc: 'é€ æˆ150%æ”»å‡»åŠ›çš„ä¼¤å®³', effect: 'damage', value: 1.5, cooldown: 3 },
            'SHIELD_BASH': { name: 'ç›¾å‡»', icon: 'ğŸ›¡ï¸', type: 'defense', desc: 'æå‡50%é˜²å¾¡å¹¶åå‡»', effect: 'defense_counter', value: 0.5, cooldown: 4 },
            'QUICK_SLASH': { name: 'ç–¾é£æ–©', icon: 'âš¡', type: 'agility', desc: 'è¿ç»­æ”»å‡»2æ¬¡ï¼Œæ¯æ¬¡70%ä¼¤å®³', effect: 'multi_attack', value: 0.7, count: 2, cooldown: 2 },
            'BERSERKER': { name: 'ç‹‚æš´', icon: 'ğŸ˜¡', type: 'buff', desc: 'æ”»å‡»åŠ›æå‡30%ï¼ŒæŒç»­3å›åˆ', effect: 'buff_attack', value: 0.3, duration: 3, cooldown: 5 },
            'IRON_WALL': { name: 'é“å£', icon: 'ğŸ°', type: 'defense', desc: 'é˜²å¾¡åŠ›æå‡50%ï¼ŒæŒç»­2å›åˆ', effect: 'buff_defense', value: 0.5, duration: 2, cooldown: 4 },
            'DODGE': { name: 'é—ªé¿', icon: 'ğŸ’¨', type: 'agility', desc: 'ä¸‹æ¬¡æ”»å‡»å¿…å®šé—ªé¿', effect: 'guaranteed_dodge', value: 1, cooldown: 3 },
            'CRITICAL_HIT': { name: 'è‡´å‘½ä¸€å‡»', icon: 'ğŸ¯', type: 'attack', desc: 'é€ æˆ200%æš´å‡»ä¼¤å®³', effect: 'critical', value: 2.0, cooldown: 5 },
            'LIFE_STEAL': { name: 'ç”Ÿå‘½æ±²å–', icon: 'ğŸ©¸', type: 'attack', desc: 'æ”»å‡»å›å¤50%ä¼¤å®³çš„ç”Ÿå‘½', effect: 'lifesteal', value: 0.5, cooldown: 4 },
            'COUNTER': { name: 'åå‡»', icon: 'â†©ï¸', type: 'defense', desc: 'å—åˆ°æ”»å‡»æ—¶åå‡»100%ä¼¤å®³', effect: 'counter', value: 1.0, cooldown: 3 },
            'SPEED_BOOST': { name: 'åŠ é€Ÿ', icon: 'ğŸš€', type: 'agility', desc: 'æ•æ·æå‡40%ï¼ŒæŒç»­2å›åˆ', effect: 'buff_agility', value: 0.4, duration: 2, cooldown: 3 }
        };
        
        // å˜å¼‚æŠ€èƒ½é…ç½®
        const MUTATION_SKILLS = {
            'MUT_DARK_POWER': { name: 'æš—é»‘ä¹‹åŠ›', icon: 'ğŸ–¤', desc: 'æ”»å‡»åŠ›+15%', effect: 'passive_attack', value: 0.15 },
            'MUT_LIGHT_HEAL': { name: 'å…‰æ˜æ²»æ„ˆ', icon: 'ğŸ¤', desc: 'æ¯å›åˆæ¢å¤5%ç”Ÿå‘½', effect: 'regen', value: 0.05 },
            'MUT_CRYSTAL_SHIELD': { name: 'æ™¶ä½“æŠ¤ç›¾', icon: 'ğŸ’', desc: 'é˜²å¾¡åŠ›+20%', effect: 'passive_defense', value: 0.2 },
            'MUT_SHADOW_SPEED': { name: 'å½±ä¹‹ç–¾è¡Œ', icon: 'ğŸ‘¤', desc: 'æ•æ·+25%', effect: 'passive_agility', value: 0.25 },
            'MUT_THUNDER_STRIKE': { name: 'é›·éœ†ä¸€å‡»', icon: 'âš¡', desc: 'æ”»å‡»é™„åŠ 30%é›·ç”µä¼¤å®³', effect: 'bonus_damage', value: 0.3 },
            'MUT_LIGHTNING_SPEED': { name: 'é—ªç”µç–¾é©°', icon: 'âš¡', desc: 'æ•æ·+30%', effect: 'passive_agility', value: 0.3 },
            'MUT_HOLY_HEAL': { name: 'åœ£å…‰æ²»ç–—', icon: 'âœ¨', desc: 'æ¯å›åˆæ¢å¤8%ç”Ÿå‘½', effect: 'regen', value: 0.08 },
            'MUT_HEAL_REDUCE': { name: 'æ²»ç–—å‰Šå¼±', icon: 'âœ¨', desc: 'æ•Œæ–¹æ²»ç–—æ•ˆæœ-50%', effect: 'heal_reduce', value: 0.5 },
            'MUT_DAMAGE_AMP': { name: 'ä¼¤å®³å¢å¹…', icon: 'ğŸ”®', desc: 'é€ æˆä¼¤å®³+25%', effect: 'damage_amp', value: 0.25 },
            'MUT_DEFENSE_AMP': { name: 'é˜²å¾¡å¢å¹…', icon: 'ğŸ”®', desc: 'å—åˆ°ä¼¤å®³-20%', effect: 'damage_reduction', value: 0.2 },
            'MUT_PERCENT_DAMAGE': { name: 'ç™¾åˆ†æ¯”ä¼¤å®³', icon: 'ğŸŒ‘', desc: 'æ”»å‡»é€ æˆæ•Œæ–¹5%æœ€å¤§ç”Ÿå‘½ä¼¤å®³', effect: 'percent_damage', value: 0.05 },
            'MUT_LIFE_DRAIN': { name: 'ç”Ÿå‘½æ±²å–', icon: 'ğŸŒ‘', desc: 'æ”»å‡»å›å¤50%ä¼¤å®³ç”Ÿå‘½', effect: 'lifesteal', value: 0.5 },
            'MUT_ANNIHILATE': { name: 'æ¹®ç­æ‰“å‡»', icon: 'ğŸ’€', desc: 'æ”»å‡»åŠ›+40%ï¼Œæ— è§†30%é˜²å¾¡', effect: 'armor_pierce', value: 0.3, attackBonus: 0.4 },
            'MUT_VOID_PIERCE': { name: 'è™šç©ºç©¿åˆº', icon: 'ğŸ’€', desc: 'æ”»å‡»é™„åŠ 20%çœŸå®ä¼¤å®³', effect: 'true_damage', value: 0.2 },
            'MUT_VOID_STRIKE': { name: 'è™šç©ºæ‰“å‡»', icon: 'ğŸŒ€', desc: 'æ”»å‡»æ— è§†50%é˜²å¾¡', effect: 'armor_pierce', value: 0.5 },
            'MUT_TEAM_SHIELD': { name: 'å›¢é˜ŸæŠ¤ç›¾', icon: 'ğŸŒ€', desc: 'é˜Ÿä¼å…¨ä½“é˜²å¾¡+20%', effect: 'passive_defense', value: 0.2 },
            'MUT_REBIRTH': { name: 'è½®å›é‡ç”Ÿ', icon: 'â™»ï¸', desc: 'æ¿’æ­»æ—¶æ¢å¤30%ç”Ÿå‘½(ä¸€æ¬¡)', effect: 'rebirth', value: 0.3 },
            'MUT_PHOENIX_FLAME': { name: 'å‡¤å‡°ä¹‹ç„°', icon: 'â™»ï¸', desc: 'æ”»å‡»é™„åŠ ç¼çƒ§æ•ˆæœï¼ŒæŒç»­3å›åˆ', effect: 'burn', value: 0.1, duration: 3 }
        };

        window.onload = function() {
            const opponentData = JSON.parse(localStorage.getItem('battleOpponent'));
            const playerData = JSON.parse(localStorage.getItem('battlePlayerAnimal'));

            if (!opponentData || !playerData) {
                alert("æˆ˜æ–—æ•°æ®åŠ è½½å¤±è´¥ï¼å°†è¿”å›ä¸»åœºæ™¯ã€‚");
                window.location.href = 'game3d.html';
                return;
            }

            // åˆå§‹åŒ–æˆ˜æ–—ç³»ç»Ÿ
            const battleSystem = new BattleSystem(playerData, opponentData);
            battleSystem.init();
        };

        // æˆ˜æ–—ç³»ç»Ÿç±»
        class BattleSystem {
            constructor(playerData, opponentData) {
                this.playerData = playerData;
                this.opponentData = opponentData;
                
                // åˆå§‹åŒ–æˆ˜æ–—çŠ¶æ€
                this.playerCurrentHealth = playerData.stamina;
                this.opponentCurrentHealth = opponentData.stamina;
                
                // æˆ˜æ–—å±æ€§ (åŒ…å«buffåŠ æˆ)
                this.playerStats = {
                    attack: playerData.abilities.combat.attack,
                    defense: playerData.abilities.combat.defense,
                    agility: playerData.abilities.combat.agility,
                    buffs: {}, // å­˜å‚¨buffæ•ˆæœ
                    activeSkills: [], // å­˜å‚¨å½“å‰ç”Ÿæ•ˆçš„æŠ€èƒ½key
                    skillCooldowns: {} // å­˜å‚¨æŠ€èƒ½å†·å´æ—¶é—´ {skillKey: remainingTurns}
                };
                
                this.opponentStats = {
                    attack: opponentData.abilities.combat.attack || 10,
                    defense: opponentData.abilities.combat.defense || 5,
                    agility: opponentData.abilities.combat.agility || 8,
                    buffs: {},
                    activeSkills: [],
                    skillCooldowns: {}
                };
                
                // è¢«åŠ¨æŠ€èƒ½
                this.playerPassiveSkills = this.getPassiveSkills(playerData);
                this.opponentPassiveSkills = this.getPassiveSkills(opponentData);
                
                // æˆ˜æ–—çŠ¶æ€
                this.battleInProgress = false;
                this.turnCount = 0;
                
                // UIå…ƒç´ 
                this.ui = {
                    battleLog: document.getElementById('battle-log'),
                    playerCard: document.getElementById('player-card'),
                    opponentCard: document.getElementById('opponent-card'),
                    btnStartBattle: document.getElementById('btn-start-battle'),
                    btnFlee: document.getElementById('btn-flee'),
                    playerTurnIndicator: document.getElementById('player-turn-indicator'),
                    opponentTurnIndicator: document.getElementById('opponent-turn-indicator')
                };
            }

            init() {
                this.renderPlayerInfo();
                this.renderOpponentInfo();
                this.renderPlayerSkillSlots();
                this.renderOpponentSkillSlots();
                this.setupEventListeners();
            }

            renderPlayerInfo() {
                document.getElementById('player-name').textContent = this.playerData.name;
                document.getElementById('player-level').textContent = `Lv. ${this.playerData.level}`;
                const playerAvatar = document.getElementById('player-avatar');
                playerAvatar.style.backgroundColor = '#' + this.playerData.color.toString(16).padStart(6, '0');
                playerAvatar.textContent = this.playerData.name.charAt(0).toUpperCase();
                document.getElementById('player-health-bar').style.width = '100%';
                document.getElementById('player-health-text').textContent = `${this.playerCurrentHealth} / ${this.playerData.stamina}`;
                document.getElementById('player-atk').textContent = this.playerStats.attack;
                document.getElementById('player-def').textContent = this.playerStats.defense;
                document.getElementById('player-agi').textContent = this.playerStats.agility;
            }

            renderOpponentInfo() {
                document.getElementById('opponent-name').textContent = this.opponentData.name;
                document.getElementById('opponent-level').textContent = `Lv. ${this.opponentData.level}`;
                const opponentAvatar = document.getElementById('opponent-avatar');
                opponentAvatar.style.backgroundColor = '#' + this.opponentData.color.toString(16).padStart(6, '0');
                opponentAvatar.textContent = this.opponentData.name.charAt(0).toUpperCase();
                document.getElementById('opponent-health-bar').style.width = '100%';
                document.getElementById('opponent-health-text').textContent = `${this.opponentCurrentHealth} / ${this.opponentData.stamina}`;
                document.getElementById('opponent-atk').textContent = this.opponentStats.attack;
                document.getElementById('opponent-def').textContent = this.opponentStats.defense;
                document.getElementById('opponent-agi').textContent = this.opponentStats.agility;
            }
            
            renderPlayerSkillSlots() {
                this.renderSkillSlots('player-skill-slots', this.playerData);
            }
            
            renderOpponentSkillSlots() {
                this.renderSkillSlots('opponent-skill-slots', this.opponentData);
            }
            
            renderSkillSlots(containerId, animalData) {
                const container = document.getElementById(containerId);
                if (!container) return;
                
                container.innerHTML = '';
                
                // è·å–å¯¹åº”çš„statsæ¥æ£€æŸ¥å†·å´
                const isPlayer = containerId.includes('player');
                const stats = isPlayer ? this.playerStats : this.opponentStats;
                
                // è¯»å–æŠ€èƒ½æ± ä»¥è·å–è‡ªå®šä¹‰æŠ€èƒ½ä¿¡æ¯
                const skillPool = JSON.parse(localStorage.getItem('SKILL_POOL') || '[]');
                
                // è·å–è£…å¤‡çš„æŠ€èƒ½
                let equippedSkills = [];
                if (animalData.combatSkills) {
                    if (Array.isArray(animalData.combatSkills)) {
                        equippedSkills = animalData.combatSkills;
                    } else if (animalData.combatSkills.equipped) {
                        equippedSkills = animalData.combatSkills.equipped;
                    }
                }
                
                // æ¸²æŸ“4ä¸ªæŠ€èƒ½æ§½
                for (let i = 0; i < 4; i++) {
                    const skillKey = equippedSkills[i];
                    let skill = COMBAT_SKILLS[skillKey] || MUTATION_SKILLS[skillKey];
                    
                    // å¦‚æœä¸æ˜¯é¢„å®šä¹‰æŠ€èƒ½ï¼Œä»æŠ€èƒ½æ± ä¸­æŸ¥æ‰¾
                    if (!skill && skillKey) {
                        const customSkill = skillPool.find(s => s.key === skillKey);
                        if (customSkill) {
                            skill = {
                                name: customSkill.name,
                                icon: customSkill.icon,
                                desc: customSkill.desc,
                                cooldown: customSkill.cooldown || 0
                            };
                        }
                    }
                    
                    const slotDiv = document.createElement('div');
                    
                    if (skill) {
                        const isMutationSkill = !!MUTATION_SKILLS[skillKey];
                        const cooldownRemaining = stats.skillCooldowns[skillKey] || 0;
                        const isOnCooldown = cooldownRemaining > 0;
                        
                        // å†·å´ä¸­æ˜¾ç¤ºç°è‰²ï¼Œå¦åˆ™æ­£å¸¸é¢œè‰²
                        const bgColor = isOnCooldown ? 'bg-gray-800/50' : (isMutationSkill ? 'bg-pink-900/20' : 'bg-purple-900/20');
                        const borderColor = isOnCooldown ? 'border-gray-700' : 'border-gray-600';
                        
                        slotDiv.className = `${bgColor} border-2 ${borderColor} rounded p-2 text-center min-h-[70px] flex flex-col items-center justify-center transition-all duration-300`;
                        slotDiv.id = `${containerId}-slot-${i}`; // æ·»åŠ IDä»¥ä¾¿è§¦å‘åŠ¨ç”»
                        
                        let cdDisplay = '';
                        if (skill.cooldown) {
                            if (isOnCooldown) {
                                cdDisplay = `<div class="text-xs text-red-400 font-bold">å†·å´:${cooldownRemaining}</div>`;
                            } else {
                                cdDisplay = `<div class="text-xs text-gray-400">CD:${skill.cooldown}</div>`;
                            }
                        }
                        
                        slotDiv.innerHTML = `
                            <div class="text-xl mb-1 ${isOnCooldown ? 'opacity-50' : ''}">${skill.icon}</div>
                            <div class="text-xs font-bold ${isOnCooldown ? 'text-gray-500' : (isMutationSkill ? 'text-pink-300' : 'text-purple-300')}">${skill.name}</div>
                            ${cdDisplay}
                        `;
                    } else {
                        slotDiv.className = 'bg-gray-700/50 border-2 border-gray-600 rounded p-2 text-center min-h-[70px] flex items-center justify-center';
                        slotDiv.innerHTML = '<span class="text-xs text-gray-500">ç©º</span>';
                    }
                    
                    container.appendChild(slotDiv);
                }
            }

            getPassiveSkills(animalData) {
                // ä»è£…å¤‡çš„æˆ˜æ–—æŠ€èƒ½ä¸­æå–è¢«åŠ¨æŠ€èƒ½
                const skills = [];
                
                // è¯»å–æŠ€èƒ½æ± ä»¥è·å–è‡ªå®šä¹‰æŠ€èƒ½ä¿¡æ¯
                const skillPool = JSON.parse(localStorage.getItem('SKILL_POOL') || '[]');
                
                // å…¼å®¹ä¸¤ç§æ•°æ®æ ¼å¼
                let equippedSkills = [];
                if (animalData.combatSkills) {
                    if (Array.isArray(animalData.combatSkills)) {
                        equippedSkills = animalData.combatSkills;
                    } else if (animalData.combatSkills.equipped) {
                        equippedSkills = animalData.combatSkills.equipped;
                    }
                }
                
                equippedSkills.forEach(skillKey => {
                    let skill = COMBAT_SKILLS[skillKey] || MUTATION_SKILLS[skillKey];
                    
                    // å¦‚æœä¸æ˜¯é¢„å®šä¹‰æŠ€èƒ½ï¼Œä»æŠ€èƒ½æ± ä¸­æŸ¥æ‰¾
                    if (!skill && skillKey) {
                        const customSkill = skillPool.find(s => s.key === skillKey);
                        if (customSkill) {
                            skill = {
                                name: customSkill.name,
                                icon: customSkill.icon,
                                desc: customSkill.description || customSkill.desc,
                                type: customSkill.type,
                                effect: customSkill.effect,
                                value: customSkill.value,
                                cooldown: customSkill.params?.cooldown || customSkill.cooldown || 0,
                                duration: customSkill.params?.duration || customSkill.duration || 0,
                                params: customSkill.params || {}
                            };
                        }
                    }
                    
                    if (skill) {
                        skills.push({
                            key: skillKey,
                            ...skill
                        });
                    }
                });
                
                return skills;
            }

            setupEventListeners() {
                this.ui.btnStartBattle.addEventListener('click', () => this.startBattle());
                this.ui.btnFlee.addEventListener('click', () => this.flee());
            }

            async startBattle() {
                if (this.battleInProgress) return;
                
                this.battleInProgress = true;
                this.ui.btnStartBattle.disabled = true;
                this.ui.btnStartBattle.textContent = 'æˆ˜æ–—ä¸­...';
                this.addLog('âš”ï¸ æˆ˜æ–—å¼€å§‹ï¼åŒæ–¹è¿›å…¥æˆ˜æ–—çŠ¶æ€ï¼');
                
                await this.sleep(2000);
                await this.battleLoop();
            }

            async battleLoop() {
                while (this.battleInProgress) {
                    this.turnCount++;
                    
                    // æ ¹æ®æ•æ·å€¼å†³å®šå‡ºæ‰‹é¡ºåº
                    const playerAgi = this.getEffectiveStat(this.playerStats, 'agility');
                    const opponentAgi = this.getEffectiveStat(this.opponentStats, 'agility');
                    
                    let firstAttacker, secondAttacker;
                    if (playerAgi >= opponentAgi) {
                        firstAttacker = 'player';
                        secondAttacker = 'opponent';
                    } else {
                        firstAttacker = 'opponent';
                        secondAttacker = 'player';
                    }
                    
                    this.addLog(`\nâ”â”â” ç¬¬ ${this.turnCount} å›åˆ â”â”â”`, 'text-cyan-400 font-bold');
                    await this.sleep(1000);
                    
                    // ç¬¬ä¸€ä¸ªæ”»å‡»è€…è¡ŒåŠ¨
                    const firstName = firstAttacker === 'player' ? this.playerData.name : this.opponentData.name;
                    this.addLog(`${firstName} å…ˆæ‰‹å‡ºå‡»ï¼`, 'text-blue-300');
                    await this.sleep(800);
                    
                    await this.executeTurn(firstAttacker);
                    if (!this.battleInProgress) break;
                    
                    await this.sleep(1500);
                    
                    // ç¬¬äºŒä¸ªæ”»å‡»è€…è¡ŒåŠ¨
                    const secondName = secondAttacker === 'player' ? this.playerData.name : this.opponentData.name;
                    this.addLog(`${secondName} åå‡»ï¼`, 'text-orange-300');
                    await this.sleep(800);
                    
                    await this.executeTurn(secondAttacker);
                    if (!this.battleInProgress) break;
                    
                    // æ›´æ–°buffæŒç»­æ—¶é—´
                    this.updateBuffs();
                    
                    await this.sleep(2000);
                }
            }

            async executeTurn(attacker) {
                const isPlayer = attacker === 'player';
                const attackerData = isPlayer ? this.playerData : this.opponentData;
                const attackerStats = isPlayer ? this.playerStats : this.opponentStats;
                const defenderStats = isPlayer ? this.opponentStats : this.playerStats;
                
                // æ˜¾ç¤ºå›åˆæŒ‡ç¤ºå™¨
                this.showTurnIndicator(isPlayer);
                
                // åªæ‰§è¡Œæ”»å‡»ï¼Œé˜²å¾¡æ”¹ä¸ºæŠ€èƒ½è§¦å‘
                await this.executeAttack(isPlayer);
                
                // éšè—å›åˆæŒ‡ç¤ºå™¨
                this.hideTurnIndicator(isPlayer);
            }

            async executeAttack(isPlayer) {
                const attackerName = isPlayer ? this.playerData.name : this.opponentData.name;
                const defenderName = isPlayer ? this.opponentData.name : this.playerData.name;
                const attackerStats = isPlayer ? this.playerStats : this.opponentStats;
                const defenderStats = isPlayer ? this.opponentStats : this.playerStats;
                
                // è§¦å‘é˜²å¾¡æ–¹çš„é˜²å¾¡æŠ€èƒ½ï¼ˆè¢«åŠ¨è§¦å‘ï¼‰
                await this.triggerDefenseSkills(!isPlayer);
                
                // æ£€æŸ¥æ˜¯å¦æœ‰ä¿è¯é—ªé¿buffï¼ˆä»…é€šè¿‡æŠ€èƒ½è§¦å‘ï¼‰
                if (defenderStats.buffs.guaranteed_dodge) {
                    this.addLog(`${defenderName} ä½¿ç”¨é—ªé¿æŠ€èƒ½ï¼Œå®Œç¾èº²å¼€äº†æ”»å‡»ï¼ğŸ’¨`, 'text-cyan-300');
                    delete defenderStats.buffs.guaranteed_dodge;
                    await this.sleep(800);
                    return;
                }
                
                // è§¦å‘æ‰€æœ‰æ”»å‡»å‹è£…å¤‡æŠ€èƒ½
                let damageMultiplier = 1.0;
                let isCriticalHit = false; // æ ‡è®°æ˜¯å¦è§¦å‘æš´å‡»æŠ€èƒ½
                const attackerSkills = isPlayer ? this.playerPassiveSkills : this.opponentPassiveSkills;
                
                // è®¡ç®—åŸºç¡€ä¼¤å®³ï¼ˆç”¨äºæŠ€èƒ½æ˜¾ç¤ºï¼‰
                const baseAttack = this.getEffectiveStat(attackerStats, 'attack');
                const defense = this.getEffectiveStat(defenderStats, 'defense');
                const baseDamage = Math.max(1, Math.floor(baseAttack - defense * 0.5));
                
                // è§¦å‘æ‰€æœ‰æ”»å‡»ç›¸å…³çš„æŠ€èƒ½ï¼ˆæ£€æŸ¥å†·å´ï¼‰
                for (const skill of attackerSkills) {
                    // è·³è¿‡æ˜ç¡®çš„é˜²å¾¡ã€æ•æ·buffæŠ€èƒ½å’Œè¢«åŠ¨æŠ€èƒ½
                    const isDefenseSkill = skill.type === 'defense' ||
                                          skill.effect === 'defense_counter' ||
                                          skill.effect === 'buff_defense' ||
                                          skill.effect === 'counter' ||
                                          skill.effect === 'passive_defense' ||
                                          skill.effect === 'damage_reduction' ||
                                          skill.effect === 'guaranteed_dodge';
                    
                    const isAgilityBuff = skill.effect === 'buff_agility' || skill.effect === 'passive_agility';
                    const isPassiveOnly = skill.effect === 'passive_attack' || skill.effect === 'regen' ||
                                         skill.effect === 'heal_reduce' || skill.effect === 'rebirth';
                    
                    if (isDefenseSkill || isAgilityBuff || isPassiveOnly) {
                        continue; // è·³è¿‡é˜²å¾¡å’Œæ•æ·æŠ€èƒ½
                    }
                    
                    // æ£€æŸ¥æŠ€èƒ½æ˜¯å¦åœ¨å†·å´ä¸­
                    if (this.isSkillOnCooldown(skill.key, isPlayer)) {
                        continue; // è·³è¿‡å†·å´ä¸­çš„æŠ€èƒ½
                    }
                    
                    // è®¡ç®—è¯¥æŠ€èƒ½çš„ä¼¤å®³è´¡çŒ®
                    let skillDamage = 0;
                    let skillMultiplier = 1.0;
                    let damageType = ''; // ä¼¤å®³ç±»å‹æè¿°
                    
                    // å¤„ç†è‡ªå®šä¹‰æŠ€èƒ½çš„paramså‚æ•°
                    const params = skill.params || {};
                    const attackBonus = params.attackBonus || skill.value || 0;
                    const multiBonus = params.multiBonus || [];
                    const count = params.count || 1;
                    
                    if (skill.effect === 'direct_attack' && attackBonus) {
                        // ç›´æ¥æ”»å‡»ï¼šattackBonusæ˜¯å›ºå®šä¼¤å®³å€¼ï¼Œç›´æ¥åŠ åˆ°åŸºç¡€ä¼¤å®³ä¸Š
                        skillDamage = Math.floor(attackBonus);
                        damageMultiplier += attackBonus / baseDamage; // è½¬æ¢ä¸ºå€ç‡ä»¥åº”ç”¨åˆ°æœ€ç»ˆä¼¤å®³
                        damageType = 'direct';
                    } else if (skill.effect === 'multi_attack' && (multiBonus.length > 0 || count > 1)) {
                        // å¤šæ®µæ”»å‡»ï¼šè®¡ç®—æ‰€æœ‰æ®µçš„æ€»ä¼¤å®³
                        let totalMultiplier = 0;
                        let hitCount = count;
                        
                        if (multiBonus.length > 0) {
                            // å¦‚æœæœ‰multiBonusæ•°ç»„
                            if (multiBonus.length === 1) {
                                // åªæœ‰ä¸€ä¸ªå€¼ï¼Œè¡¨ç¤ºæ¯æ®µéƒ½æ˜¯è¿™ä¸ªå€ç‡
                                totalMultiplier = multiBonus[0] * count;
                                hitCount = count;
                            } else {
                                // å¤šä¸ªå€¼ï¼Œæ¯æ®µä½¿ç”¨å¯¹åº”å€ç‡
                                for (let i = 0; i < count && i < multiBonus.length; i++) {
                                    totalMultiplier += multiBonus[i];
                                }
                                hitCount = Math.min(count, multiBonus.length);
                            }
                        } else {
                            // æ²¡æœ‰multiBonusï¼Œé»˜è®¤æ¯æ®µ100%ä¼¤å®³
                            totalMultiplier = count;
                        }
                        
                        skillDamage = Math.floor(baseDamage * totalMultiplier);
                        damageMultiplier = Math.max(damageMultiplier, totalMultiplier);
                        damageType = 'multi';
                        skill._hitCount = hitCount; // ä¿å­˜æ®µæ•°ç”¨äºæ˜¾ç¤º
                    } else if (skill.effect === 'critical' && skill.value) {
                        skillMultiplier = skill.value;
                        skillDamage = Math.floor(baseDamage * skillMultiplier);
                        damageType = 'critical';
                    } else if (skill.effect === 'damage' && skill.value) {
                        skillMultiplier = skill.value;
                        skillDamage = Math.floor(baseDamage * skillMultiplier);
                        damageType = 'damage';
                    } else if (skill.effect === 'bonus_damage' && skill.value) {
                        skillDamage = Math.floor(baseDamage * skill.value);
                        damageType = 'bonus';
                    } else if (skill.effect === 'percent_damage' && skill.value) {
                        const targetMaxHealth = isPlayer ? this.opponentData.stamina : this.playerData.stamina;
                        skillDamage = Math.floor(targetMaxHealth * skill.value);
                        damageType = 'percent';
                    } else if (skill.effect === 'true_damage' && skill.value) {
                        skillDamage = Math.floor(baseAttack * skill.value);
                        damageType = 'true';
                    } else if (skill.effect === 'damage_amp' && skill.value) {
                        skillDamage = Math.floor(baseDamage * skill.value);
                        damageType = 'amp';
                    } else if (skill.effect === 'armor_pierce' && skill.value) {
                        const ignoredDefense = Math.floor(defense * skill.value);
                        skillDamage = Math.floor(ignoredDefense * 0.5);
                        damageType = 'pierce';
                    } else if (skill.effect === 'buff_attack' && skill.value) {
                        const attackBoostValue = Math.floor(baseAttack * skill.value);
                        skillDamage = Math.floor(attackBoostValue);
                        damageType = 'buff';
                    } else if (skill.effect === 'lifesteal' && skill.value) {
                        skillDamage = baseDamage;
                        damageType = 'lifesteal';
                    } else if (skill.value) {
                        if (skill.value > 1.0) {
                            skillMultiplier = skill.value;
                            skillDamage = Math.floor(baseDamage * skillMultiplier);
                            damageType = 'multiplier';
                        } else if (skill.value > 0 && skill.value <= 1.0) {
                            skillDamage = Math.floor(baseDamage * skill.value);
                            damageType = 'bonus';
                        }
                    }
                    
                    // å¦‚æœæ²¡æœ‰è®¡ç®—å‡ºä¼¤å®³ï¼Œè·³è¿‡è¿™ä¸ªæŠ€èƒ½
                    if (skillDamage === 0 && damageType === '') {
                        continue;
                    }
                    
                    // æ„å»ºä¼¤å®³ä¿¡æ¯å­—ç¬¦ä¸²
                    let damageInfo = '';
                    if (damageType === 'direct') {
                        damageInfo = `å›ºå®šä¼¤å®³: ${skillDamage}`;
                    } else if (damageType === 'multi') {
                        const hitCount = skill._hitCount || count;
                        damageInfo = `å¤šæ®µä¼¤å®³: ${skillDamage} (${hitCount}æ®µ)`;
                    } else if (damageType === 'critical') {
                        damageInfo = `æš´å‡»ä¼¤å®³: ${skillDamage}`;
                    } else if (damageType === 'percent') {
                        damageInfo = `ç™¾åˆ†æ¯”ä¼¤å®³: ${skillDamage}`;
                    } else if (damageType === 'true') {
                        damageInfo = `çœŸå®ä¼¤å®³: ${skillDamage}`;
                    } else if (damageType === 'pierce') {
                        damageInfo = `ç©¿é€ä¼¤å®³: +${skillDamage}`;
                    } else if (damageType === 'buff') {
                        damageInfo = `æ”»å‡»æå‡: +${skillDamage}`;
                    } else if (damageType === 'lifesteal') {
                        damageInfo = `ä¼¤å®³: ${skillDamage}, æ±²å–: ${Math.floor(skillDamage * skill.value)}`;
                    } else if (damageType === 'multiplier') {
                        damageInfo = `ä¼¤å®³: ${skillDamage} (${(skillMultiplier * 100).toFixed(0)}%å€ç‡)`;
                    } else if (damageType === 'bonus' || damageType === 'amp') {
                        damageInfo = `é¢å¤–ä¼¤å®³: +${skillDamage}`;
                    } else if (damageType === 'damage') {
                        damageInfo = `ä¼¤å®³: ${skillDamage} (${(skillMultiplier * 100).toFixed(0)}%å€ç‡)`;
                    }
                    
                    await this.triggerSkillEffect(skill, isPlayer, damageInfo);
                    
                    // åº”ç”¨æŠ€èƒ½æ•ˆæœ
                    if (skill.effect === 'critical' && skill.value) {
                        // æš´å‡»æŠ€èƒ½è§¦å‘
                        isCriticalHit = true;
                        damageMultiplier = Math.max(damageMultiplier, skill.value);
                    } else if (skill.value && skill.value > 1.0 && !skill.effect.includes('buff')) {
                        damageMultiplier = Math.max(damageMultiplier, skill.value);
                    }
                    
                    // è®¾ç½®å†·å´
                    if (skill.cooldown) {
                        this.setSkillCooldown(skill.key, skill.cooldown, isPlayer);
                    }
                }
                
                // è®¡ç®—æœ€ç»ˆä¼¤å®³
                let damage = Math.max(1, Math.floor(baseDamage * damageMultiplier));
                
                // åº”ç”¨ä¼¤å®³
                if (isPlayer) {
                    this.opponentCurrentHealth = Math.max(0, this.opponentCurrentHealth - damage);
                    this.shakeCard(false);
                } else {
                    this.playerCurrentHealth = Math.max(0, this.playerCurrentHealth - damage);
                    this.shakeCard(true);
                }
                
                // æ˜¾ç¤ºä¼¤å®³ä¿¡æ¯
                const critText = isCriticalHit ? 'ğŸ’¥ æš´å‡»ï¼' : '';
                this.addLog(`${critText}${attackerName} å¯¹ ${defenderName} é€ æˆ ${damage} ç‚¹ä¼¤å®³ï¼`, isCriticalHit ? 'text-red-400 font-bold' : 'text-red-300');
                await this.sleep(1000);
                
                // ç”Ÿå‘½æ±²å–æ•ˆæœ
                if (attackerStats.buffs.lifesteal) {
                    const heal = Math.floor(damage * 0.5);
                    if (isPlayer) {
                        this.playerCurrentHealth = Math.min(this.playerData.stamina, this.playerCurrentHealth + heal);
                    } else {
                        this.opponentCurrentHealth = Math.min(this.opponentData.stamina, this.opponentCurrentHealth + heal);
                    }
                    this.addLog(`${attackerName} æ±²å–äº† ${heal} ç‚¹ç”Ÿå‘½å€¼ï¼ğŸ©¸`, 'text-pink-300');
                    await this.sleep(800);
                }
                
                // åå‡»æ•ˆæœ
                if (defenderStats.buffs.counter) {
                    // é«˜äº®åå‡»æŠ€èƒ½
                    await this.highlightSkillByEffect(isPlayer ? 'opponent' : 'player', 'counter');
                    
                    const counterDamage = Math.floor(damage * 0.5);
                    if (isPlayer) {
                        this.opponentCurrentHealth = Math.max(0, this.opponentCurrentHealth - counterDamage);
                    } else {
                        this.playerCurrentHealth = Math.max(0, this.playerCurrentHealth - counterDamage);
                    }
                    this.addLog(`${defenderName} å‘åŠ¨åå‡»ï¼Œé€ æˆ ${counterDamage} ç‚¹ä¼¤å®³ï¼â†©ï¸`, 'text-purple-300');
                    await this.sleep(800);
                }
                
                this.updateHealthUI();
                await this.checkBattleEnd();
            }

            async triggerDefenseSkills(isDefender) {
                const defenderName = isDefender ? this.playerData.name : this.opponentData.name;
                const defenderStats = isDefender ? this.playerStats : this.opponentStats;
                const defenderCard = isDefender ? this.ui.playerCard : this.ui.opponentCard;
                const defenderSkills = isDefender ? this.playerPassiveSkills : this.opponentPassiveSkills;
                
                let hasDefenseSkill = false;
                
                // è§¦å‘æ‰€æœ‰é˜²å¾¡ç›¸å…³çš„æŠ€èƒ½ï¼ˆæ£€æŸ¥å†·å´ï¼‰
                for (const skill of defenderSkills) {
                    if (skill.type === 'defense' || skill.effect === 'defense_counter' ||
                        skill.effect === 'buff_defense' || skill.effect === 'counter' ||
                        skill.effect === 'passive_defense' || skill.effect === 'damage_reduction') {
                        
                        // æ£€æŸ¥æŠ€èƒ½æ˜¯å¦åœ¨å†·å´ä¸­
                        if (this.isSkillOnCooldown(skill.key, isDefender)) {
                            continue; // è·³è¿‡å†·å´ä¸­çš„æŠ€èƒ½
                        }
                        
                        hasDefenseSkill = true;
                        
                        // è®¡ç®—é˜²å¾¡åŠ æˆä¿¡æ¯
                        let defenseInfo = '';
                        if (skill.value) {
                            const defenseBoost = Math.floor(this.getEffectiveStat(defenderStats, 'defense') * skill.value);
                            defenseInfo = `é˜²å¾¡æå‡: +${defenseBoost}`;
                        }
                        
                        await this.triggerSkillEffect(skill, isDefender, defenseInfo);
                        
                        // åº”ç”¨é˜²å¾¡åŠ æˆ
                        if (skill.value) {
                            defenderStats.buffs.defense_boost = { value: skill.value, duration: 1 };
                        }
                        
                        // æ˜¾ç¤ºé˜²å¾¡æ•ˆæœ
                        defenderCard.classList.add('animate-defend');
                        await this.sleep(500);
                        defenderCard.classList.remove('animate-defend');
                        
                        // è®¾ç½®å†·å´
                        if (skill.cooldown) {
                            this.setSkillCooldown(skill.key, skill.cooldown, isDefender);
                        }
                    }
                }
                
                // å¦‚æœæœ‰é˜²å¾¡æŠ€èƒ½ï¼Œæ˜¾ç¤ºé˜²å¾¡å§¿æ€
                if (hasDefenseSkill) {
                    defenderStats.buffs.defending = { value: 0.3, duration: 1 };
                }
            }

            async triggerSkillEffect(skill, isPlayer, damageInfo = null) {
                // æ˜¾ç¤ºæ—¥å¿—ï¼ŒåŒ…å«ä¼¤å®³è®¡ç®—ä¿¡æ¯
                let logMessage = `âœ¨ ${isPlayer ? 'æˆ‘æ–¹' : 'æ•Œæ–¹'}æŠ€èƒ½ [${skill.name}] è§¦å‘ï¼`;
                if (damageInfo) {
                    logMessage += ` (${damageInfo})`;
                }
                this.addLog(logMessage, 'text-purple-300');
                
                // æ‰¾åˆ°å¹¶é«˜äº®å¯¹åº”çš„æŠ€èƒ½æ§½
                const containerId = isPlayer ? 'player-skill-slots' : 'opponent-skill-slots';
                const stats = isPlayer ? this.playerStats : this.opponentStats;
                const container = document.getElementById(containerId);
                if (!container) return;
                
                // è·å–è£…å¤‡çš„æŠ€èƒ½åˆ—è¡¨
                const animalData = isPlayer ? this.playerData : this.opponentData;
                let equippedSkills = [];
                if (animalData.combatSkills) {
                    if (Array.isArray(animalData.combatSkills)) {
                        equippedSkills = animalData.combatSkills;
                    } else if (animalData.combatSkills.equipped) {
                        equippedSkills = animalData.combatSkills.equipped;
                    }
                }
                
                // æ‰¾åˆ°æŠ€èƒ½åœ¨æ§½ä½ä¸­çš„ç´¢å¼•
                const skillIndex = equippedSkills.indexOf(skill.key);
                if (skillIndex !== -1) {
                    const slotElement = document.getElementById(`${containerId}-slot-${skillIndex}`);
                    if (slotElement) {
                        // è§¦å‘åŠ¨ç”»
                        slotElement.classList.add('skill-triggered');
                        await this.sleep(600);
                        slotElement.classList.remove('skill-triggered');
                        
                        // å¦‚æœæ˜¯æœ‰æŒç»­æ—¶é—´çš„buffæŠ€èƒ½ï¼Œæ·»åŠ æŒç»­é«˜äº®
                        if (skill.duration && skill.duration > 0) {
                            // è®°å½•æŠ€èƒ½ç”Ÿæ•ˆ
                            if (!stats.activeSkills.includes(skill.key)) {
                                stats.activeSkills.push(skill.key);
                            }
                            slotElement.classList.add('skill-active');
                            
                            // åœ¨buffä¸­è®°å½•æŠ€èƒ½keyå’Œæ§½ä½ç´¢å¼•ï¼Œç”¨äºåç»­ç§»é™¤é«˜äº®
                            const buffKey = `buff_${skill.effect.split('_')[1] || skill.effect}`;
                            if (stats.buffs[buffKey]) {
                                stats.buffs[buffKey].skillKey = skill.key;
                                stats.buffs[buffKey].slotIndex = skillIndex;
                                stats.buffs[buffKey].containerId = containerId;
                            }
                        }
                    }
                }
            }

            getEffectiveStat(stats, statName) {
                let value = stats[statName];
                
                // åº”ç”¨buffåŠ æˆ
                if (stats.buffs[`buff_${statName}`]) {
                    value = Math.floor(value * (1 + stats.buffs[`buff_${statName}`].value));
                }
                
                if (stats.buffs.defending && statName === 'defense') {
                    value = Math.floor(value * 1.3);
                }
                
                if (stats.buffs.defense_boost && statName === 'defense') {
                    value = Math.floor(value * (1 + stats.buffs.defense_boost.value));
                }
                
                return value;
            }

            updateBuffs() {
                // æ›´æ–°ç©å®¶buff
                for (const [key, buff] of Object.entries(this.playerStats.buffs)) {
                    if (buff.duration !== undefined) {
                        buff.duration--;
                        if (buff.duration <= 0) {
                            // buffç»“æŸæ—¶ï¼Œç§»é™¤å¯¹åº”æŠ€èƒ½çš„é«˜äº®
                            if (buff.skillKey && buff.slotIndex !== undefined && buff.containerId) {
                                const slotElement = document.getElementById(`${buff.containerId}-slot-${buff.slotIndex}`);
                                if (slotElement) {
                                    slotElement.classList.remove('skill-active');
                                }
                                // ä»activeSkillsä¸­ç§»é™¤
                                const index = this.playerStats.activeSkills.indexOf(buff.skillKey);
                                if (index > -1) {
                                    this.playerStats.activeSkills.splice(index, 1);
                                }
                            }
                            delete this.playerStats.buffs[key];
                        }
                    }
                }
                
                // æ›´æ–°å¯¹æ‰‹buff
                for (const [key, buff] of Object.entries(this.opponentStats.buffs)) {
                    if (buff.duration !== undefined) {
                        buff.duration--;
                        if (buff.duration <= 0) {
                            // buffç»“æŸæ—¶ï¼Œç§»é™¤å¯¹åº”æŠ€èƒ½çš„é«˜äº®
                            if (buff.skillKey && buff.slotIndex !== undefined && buff.containerId) {
                                const slotElement = document.getElementById(`${buff.containerId}-slot-${buff.slotIndex}`);
                                if (slotElement) {
                                    slotElement.classList.remove('skill-active');
                                }
                                // ä»activeSkillsä¸­ç§»é™¤
                                const index = this.opponentStats.activeSkills.indexOf(buff.skillKey);
                                if (index > -1) {
                                    this.opponentStats.activeSkills.splice(index, 1);
                                }
                            }
                            delete this.opponentStats.buffs[key];
                        }
                    }
                }
                
                // æ›´æ–°æŠ€èƒ½å†·å´
                this.updateSkillCooldowns();
            }
            
            updateSkillCooldowns() {
                // æ›´æ–°ç©å®¶æŠ€èƒ½å†·å´
                for (const [skillKey, cooldown] of Object.entries(this.playerStats.skillCooldowns)) {
                    this.playerStats.skillCooldowns[skillKey]--;
                    if (this.playerStats.skillCooldowns[skillKey] <= 0) {
                        delete this.playerStats.skillCooldowns[skillKey];
                    }
                }
                
                // æ›´æ–°å¯¹æ‰‹æŠ€èƒ½å†·å´
                for (const [skillKey, cooldown] of Object.entries(this.opponentStats.skillCooldowns)) {
                    this.opponentStats.skillCooldowns[skillKey]--;
                    if (this.opponentStats.skillCooldowns[skillKey] <= 0) {
                        delete this.opponentStats.skillCooldowns[skillKey];
                    }
                }
                
                // åˆ·æ–°æŠ€èƒ½æ§½æ˜¾ç¤º
                this.renderPlayerSkillSlots();
                this.renderOpponentSkillSlots();
            }
            
            isSkillOnCooldown(skillKey, isPlayer) {
                const stats = isPlayer ? this.playerStats : this.opponentStats;
                return (stats.skillCooldowns[skillKey] || 0) > 0;
            }
            
            setSkillCooldown(skillKey, cooldown, isPlayer) {
                const stats = isPlayer ? this.playerStats : this.opponentStats;
                stats.skillCooldowns[skillKey] = cooldown;
            }

            showTurnIndicator(isPlayer) {
                if (isPlayer) {
                    this.ui.playerTurnIndicator.style.display = 'block';
                } else {
                    this.ui.opponentTurnIndicator.style.display = 'block';
                }
            }

            hideTurnIndicator(isPlayer) {
                if (isPlayer) {
                    this.ui.playerTurnIndicator.style.display = 'none';
                } else {
                    this.ui.opponentTurnIndicator.style.display = 'none';
                }
            }

            shakeCard(isPlayer) {
                const card = isPlayer ? this.ui.playerCard : this.ui.opponentCard;
                card.classList.add('animate-shake');
                setTimeout(() => {
                    card.classList.remove('animate-shake');
                }, 300);
            }

            updateHealthUI() {
                // æ›´æ–°ç©å®¶è¡€æ¡
                const playerHealthPercent = Math.max(0, (this.playerCurrentHealth / this.playerData.stamina) * 100);
                document.getElementById('player-health-bar').style.width = `${playerHealthPercent}%`;
                document.getElementById('player-health-text').textContent = `${this.playerCurrentHealth} / ${this.playerData.stamina}`;

                // æ›´æ–°å¯¹æ‰‹è¡€æ¡
                const opponentHealthPercent = Math.max(0, (this.opponentCurrentHealth / this.opponentData.stamina) * 100);
                document.getElementById('opponent-health-bar').style.width = `${opponentHealthPercent}%`;
                document.getElementById('opponent-health-text').textContent = `${this.opponentCurrentHealth} / ${this.opponentData.stamina}`;
            }

            async checkBattleEnd() {
                if (this.opponentCurrentHealth <= 0) {
                    this.battleInProgress = false;
                    await this.handleVictory();
                    return true;
                }
                if (this.playerCurrentHealth <= 0) {
                    this.battleInProgress = false;
                    await this.handleDefeat();
                    return true;
                }
                return false;
            }

            async handleVictory() {
                this.addLog(`\nğŸ‰ èƒœåˆ©ï¼ä½ å‡»è´¥äº† ${this.opponentData.name}ï¼`, 'text-green-400 font-bold text-lg');
                
                // æ£€æŸ¥æ˜¯å¦æ˜¯é€šç¼‰ä»»åŠ¡
                const activeBountyId = localStorage.getItem('activeBountyId');
                if (activeBountyId) {
                    localStorage.setItem('bountyBattleResult', 'won');
                }
                
                await this.sleep(2000);
                
                // å¦‚æœæ˜¯é‡ç”ŸåŠ¨ç‰©ï¼Œæ˜¾ç¤ºæ•è·é€‰é¡¹
                if (this.opponentData.isWild) {
                    this.showCaptureOptions();
                } else {
                    this.processXpAndLevelUp();
                }
            }

            async handleDefeat() {
                this.addLog(`\nğŸ’€ æˆ˜è´¥...ä½ è¢« ${this.opponentData.name} å‡»è´¥äº†...`, 'text-red-400 font-bold text-lg');
                await this.sleep(2000);
                this.showReturnButton("æˆ˜æ–—å¤±è´¥ï¼Œè¿”å›ä¸»åœºæ™¯");
            }

            showCaptureOptions() {
                const actionPanel = document.querySelector('.action-panel');
                actionPanel.innerHTML = '';
                
                this.addLog(`è¦å°è¯•æ•è· ${this.opponentData.name} å—ï¼Ÿ`, 'text-yellow-300');
                
                const captureButton = document.createElement('button');
                captureButton.textContent = 'âœ… æ•è·';
                captureButton.className = 'action-button bg-green-600 hover:bg-green-700';
                captureButton.onclick = () => {
                    localStorage.setItem('capturedAnimal', JSON.stringify(this.opponentData));
                    this.addLog(`æˆåŠŸæ•è·äº† ${this.opponentData.name}ï¼å®ƒå°†è¢«ä¼ é€å›ä½ çš„æ –æ¯åœ°ã€‚`, 'text-green-400');
                    actionPanel.querySelectorAll('button').forEach(btn => btn.disabled = true);
                    setTimeout(() => this.showReturnButton("æ•è·æˆåŠŸï¼Œè¿”å›ä¸»åœºæ™¯"), 1500);
                };
                
                const releaseButton = document.createElement('button');
                releaseButton.textContent = 'âŒ æ”¾èµ°';
                releaseButton.className = 'action-button flee-button';
                releaseButton.onclick = () => {
                    this.addLog(`ä½ æ”¾èµ°äº† ${this.opponentData.name}ã€‚`, 'text-gray-400');
                    actionPanel.querySelectorAll('button').forEach(btn => btn.disabled = true);
                    setTimeout(() => this.processXpAndLevelUp(), 1000);
                };
                
                actionPanel.appendChild(captureButton);
                actionPanel.appendChild(releaseButton);
            }

            processXpAndLevelUp() {
                const xpGained = this.opponentData.level * 15;
                this.playerData.xp = (this.playerData.xp || 0) + xpGained;
                this.addLog(`ä½ è·å¾—äº† ${xpGained} ç‚¹ç»éªŒå€¼ï¼`, 'text-yellow-300');
                
                let leveledUp = false;
                const xpToNextLevel = this.playerData.xpToNextLevel || this.playerData.level * 100;
                
                while (this.playerData.xp >= xpToNextLevel) {
                    leveledUp = true;
                    this.playerData.level++;
                    this.playerData.xp -= xpToNextLevel;
                    this.playerData.stamina += 20;
                    this.playerData.xpToNextLevel = this.playerData.level * 100;
                }
                
                localStorage.setItem('playerAnimal', JSON.stringify(this.playerData));
                
                setTimeout(() => {
                    if (leveledUp) {
                        this.addLog(`ğŸ‰ æ­å–œï¼${this.playerData.name} å‡åˆ°äº† ${this.playerData.level} çº§ï¼`, 'text-green-400 font-bold');
                    }
                    this.showReturnButton("æˆ˜æ–—èƒœåˆ©ï¼Œè¿”å›ä¸»åœºæ™¯");
                }, 1500);
            }

            showReturnButton(message) {
                const actionPanel = document.querySelector('.action-panel');
                actionPanel.innerHTML = '';
                
                const returnButton = document.createElement('button');
                returnButton.textContent = message;
                returnButton.className = 'return-button';
                returnButton.onclick = () => {
                    const returnUrl = localStorage.getItem('battleReturnUrl') || 'game3d.html';
                    localStorage.removeItem('battleOpponent');
                    localStorage.removeItem('battlePlayerAnimal');
                    localStorage.removeItem('battleReturnUrl');
                    window.location.href = returnUrl;
                };
                
                actionPanel.appendChild(returnButton);
            }

            flee() {
                if (confirm("ç¡®å®šè¦ä»æˆ˜æ–—ä¸­é€ƒè·‘å—ï¼Ÿ")) {
                    localStorage.removeItem('battleOpponent');
                    localStorage.removeItem('battlePlayerAnimal');
                    window.location.href = 'game3d.html';
                }
            }

            addLog(message, className = 'text-gray-300') {
                const logContainer = this.ui.battleLog;
                const logEntry = document.createElement('div');
                logEntry.className = className;
                logEntry.textContent = message;
                logContainer.appendChild(logEntry);
                
                // è‡ªåŠ¨æ»šåŠ¨åˆ°åº•éƒ¨
                logContainer.parentElement.scrollTop = logContainer.parentElement.scrollHeight;
            }

            sleep(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
            
            // æ–°å¢ï¼šæ ¹æ®æ•ˆæœç±»å‹é«˜äº®æŠ€èƒ½
            async highlightSkillByEffect(side, effectType) {
                const containerId = side === 'player' ? 'player-skill-slots' : 'opponent-skill-slots';
                const animalData = side === 'player' ? this.playerData : this.opponentData;
                
                // è¯»å–æŠ€èƒ½æ± ä»¥è·å–è‡ªå®šä¹‰æŠ€èƒ½ä¿¡æ¯
                const skillPool = JSON.parse(localStorage.getItem('SKILL_POOL') || '[]');
                
                // è·å–è£…å¤‡çš„æŠ€èƒ½åˆ—è¡¨
                let equippedSkills = [];
                if (animalData.combatSkills) {
                    if (Array.isArray(animalData.combatSkills)) {
                        equippedSkills = animalData.combatSkills;
                    } else if (animalData.combatSkills.equipped) {
                        equippedSkills = animalData.combatSkills.equipped;
                    }
                }
                
                // æŸ¥æ‰¾å…·æœ‰è¯¥æ•ˆæœçš„æŠ€èƒ½
                equippedSkills.forEach((skillKey, index) => {
                    let skill = COMBAT_SKILLS[skillKey] || MUTATION_SKILLS[skillKey];
                    
                    // å¦‚æœä¸æ˜¯é¢„å®šä¹‰æŠ€èƒ½ï¼Œä»æŠ€èƒ½æ± ä¸­æŸ¥æ‰¾
                    if (!skill && skillKey) {
                        const customSkill = skillPool.find(s => s.key === skillKey);
                        if (customSkill) {
                            skill = {
                                effect: customSkill.effect
                            };
                        }
                    }
                    
                    if (skill && skill.effect === effectType) {
                        const slotElement = document.getElementById(`${containerId}-slot-${index}`);
                        if (slotElement) {
                            slotElement.classList.add('skill-triggered');
                            setTimeout(() => {
                                slotElement.classList.remove('skill-triggered');
                            }, 600);
                        }
                    }
                });
            }
        }
    </script>

</body>
</html>

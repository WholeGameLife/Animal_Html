<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç”µå­ç›†æ ½ - åŒºåŸŸæ¢ç´¢</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Inter', sans-serif; }
        canvas { display: block; }
        .game-ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        .control-panel { pointer-events: auto; background: rgba(17, 24, 39, 0.9); backdrop-filter: blur(5px); border: 1px solid #374151; }
        .centered-panel { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 50; }
        #modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.7); z-index: 40; }
    </style>
</head>
<body>
    <div id="modal-overlay" class="hidden"></div>
    <div id="container"></div>

    <div class="game-ui p-4 flex flex-col justify-between items-start">
        <!-- Top Left: World Info & Return Button -->
        <div class="control-panel p-4 rounded-lg text-white">
            <h1 id="world-name" class="text-2xl font-bold text-yellow-300 mb-2">æ¢ç´¢åŒºåŸŸ</h1>
            <button id="btn-return-map" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg">è¿”å›ä¸–ç•Œåœ°å›¾</button>
        </div>

        <!-- Animal Details Panel (æ–°å¢) -->
        <div id="animal-details-panel" class="control-panel p-4 rounded-lg text-white hidden w-full md:w-96" style="position: absolute; z-index: 100;">
            <h3 class="text-xl font-bold mb-3 text-fuchsia-400 border-b border-gray-700 pb-2 flex justify-between items-center">
                <span>åŠ¨ç‰©è¯¦æƒ…</span>
                <button id="btn-close-animal-details" class="text-sm font-normal text-gray-400 hover:text-white">å…³é—­</button>
            </h3>
            <div id="animal-detail-content">
                <h4 class="text-lg font-bold text-fuchsia-400 flex justify-between items-center">
                    <span id="detail-animal-name">åŠ¨ç‰©åç§°</span>
                    <div class="flex items-center space-x-2">
                        <span id="detail-animal-gender" class="text-sm font-normal px-2 py-1 rounded"></span>
                        <span id="detail-animal-level" class="text-sm font-normal bg-purple-600 px-2 py-1 rounded">Lv. 1</span>
                    </div>
                </h4>

                <!-- ç»éªŒè¿›åº¦æ¡ -->
                <div class="my-2">
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>ç»éªŒ</span>
                        <span id="detail-animal-exp-text">0 / 100</span>
                    </div>
                    <div class="w-full bg-gray-700 rounded-full h-2">
                        <div id="detail-animal-exp-bar" class="bg-yellow-400 h-2 rounded-full" style="width: 0%"></div>
                    </div>
                </div>

                <!-- å±æ€§ä¸èƒ½åŠ›ç»Ÿä¸€æ˜¾ç¤º -->
                <div class="text-sm space-y-3 mt-3">
                    <!-- åŸºç¡€å±æ€§ -->
                    <div class="space-y-1">
                        <p class="font-semibold text-cyan-400 mb-1">åŸºç¡€å±æ€§</p>
                        <p class="ml-2">â­ ç¨€æœ‰åº¦: <span id="detail-animal-rarity" class="font-mono font-bold"></span></p>
                        <p class="ml-2">â¤ï¸ ä½“åŠ›: <span id="detail-animal-stamina" class="font-mono text-green-300"></span></p>
                        <p class="ml-2">âœ¨ æ½œåŠ›: <span id="detail-animal-potential" class="font-mono text-yellow-300"></span></p>
                        <p class="ml-2">ğŸŒ€ ç³»åˆ«: <span id="detail-animal-element" class="font-mono text-cyan-300"></span></p>
                    </div>
                    
                    <!-- æˆ˜æ–—èƒ½åŠ› -->
                    <div class="space-y-1 border-t border-gray-700 pt-2">
                        <p class="font-semibold text-indigo-300 mb-1">æˆ˜æ–—èƒ½åŠ›</p>
                        <p class="ml-2 text-xs">âš”ï¸ æ”»å‡»: <span id="detail-ability-combat-atk" class="font-mono text-red-400"></span></p>
                        <p class="ml-2 text-xs">ğŸ›¡ï¸ é˜²å¾¡: <span id="detail-ability-combat-def" class="font-mono text-blue-400"></span></p>
                        <p class="ml-2 text-xs">âš¡ æ•æ·: <span id="detail-ability-combat-agi" class="font-mono text-yellow-400"></span></p>
                    </div>
                    
                    <!-- æˆ˜æ–—æŠ€èƒ½ -->
                    <div class="border-t border-gray-700 pt-2">
                        <p class="font-semibold text-indigo-300 mb-2">æˆ˜æ–—æŠ€èƒ½</p>
                        <div id="detail-combat-skills" class="grid grid-cols-4 gap-1">
                            <!-- æŠ€èƒ½æ§½ä½ç”± JS ç”Ÿæˆ -->
                        </div>
                    </div>
                </div>

                <div class="mt-4 border-t border-gray-700 pt-3">
                    <button id="btn-challenge-animal" class="w-full bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg">
                        âš”ï¸ æŒ‘æˆ˜
                    </button>
                </div>
            </div>
        </div>

        <!-- Battle Setup Panel (copied from game3d.html) -->
        <div id="battle-setup-panel" class="control-panel centered-panel p-4 rounded-lg text-white hidden w-full md:w-[450px]">
            <h3 class="text-xl font-bold mb-3 text-red-500 border-b border-gray-700 pb-2 flex justify-center items-center">
                <span>æˆ˜æ–—å‡†å¤‡</span>
            </h3>
            <div class="flex space-x-4 mb-4">
                <div class="w-1/2">
                    <p class="text-sm font-semibold text-gray-400 mb-2">é€‰æ‹©ä½ çš„å‹‡å£« (1åª)</p>
                    <div id="battle-team-selection-list" class="space-y-2 max-h-64 overflow-y-auto"></div>
                </div>
                <div class="w-1/2">
                    <p class="text-sm font-semibold text-gray-400 mb-2">æŒ‘æˆ˜å¯¹æ‰‹</p>
                    <div id="battle-opponent-info" class="p-2 rounded-lg bg-gray-900 flex items-center justify-between"></div>
                </div>
            </div>
            <div class="flex space-x-2 mt-4">
                <button id="btn-execute-battle" class="flex-1 bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-3 rounded-lg text-center text-sm" disabled>å‘èµ·æŒ‘æˆ˜</button>
                <button id="btn-close-battle-setup-panel" class="flex-1 bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-3 rounded-lg text-center text-sm">å–æ¶ˆ</button>
            </div>
        </div>
    </div>

    <script>
        // --- Config ---
        // ä»åœ°å›¾é…ç½®å™¨è¯»å–é…ç½®
        const mapConfigs = JSON.parse(localStorage.getItem('MAP_CONFIGS') || '[]');
        const animalPool = JSON.parse(localStorage.getItem('ANIMAL_POOL') || '[]');
        
        const WORLD_CONFIG = {
            volcano: { name: 'ç†”å²©ç«å±±', groundColor: 0x5c1c1c, animalElement: 'ç«', maxAnimals: 7 },
            underwater: { name: 'æ·±æµ·é—è¿¹', groundColor: 0x1a3a5c, animalElement: 'æ°´', maxAnimals: 7 },
            sky_city: { name: 'å¤©ç©ºä¹‹åŸ', groundColor: 0x87ceeb, animalElement: 'é£', maxAnimals: 7 },
            marsh: { name: 'å¹½æš—æ²¼æ³½', groundColor: 0x556b2f, animalElement: 'æœ¨', maxAnimals: 7 },
        };
        
        // è·å–å½“å‰åœ°å›¾çš„é…ç½®
        function getCurrentMapConfig() {
            // å°è¯•é€šè¿‡URLå‚æ•°ä¸­çš„mapKeyæŸ¥æ‰¾é…ç½®
            const urlParams = new URLSearchParams(window.location.search);
            const mapKey = urlParams.get('mapKey');
            
            if (mapKey) {
                const config = mapConfigs.find(m => m.key === mapKey);
                if (config) return config;
            }
            
            // å¦‚æœæ²¡æœ‰æ‰¾åˆ°ï¼Œè¿”å›nullä½¿ç”¨é»˜è®¤é…ç½®
            return null;
        }

        // æˆ˜æ–—æŠ€èƒ½é…ç½®ï¼ˆä¸game3d.htmlä¿æŒä¸€è‡´ï¼‰
        const COMBAT_SKILLS = {
            'strike': { name: 'çŒ›å‡»', desc: 'é€ æˆ120%æ”»å‡»åŠ›çš„ä¼¤å®³', type: 'attack', power: 1.2, icon: 'ğŸ‘Š' },
            'heal': { name: 'æ²»ç–—', desc: 'æ¢å¤20%æœ€å¤§ç”Ÿå‘½å€¼', type: 'heal', power: 0.2, icon: 'ğŸ’š' },
            'fireball': { name: 'ç«çƒæœ¯', desc: 'é€ æˆ150%æ”»å‡»åŠ›çš„ç«å±æ€§ä¼¤å®³', type: 'attack', power: 1.5, icon: 'ğŸ”¥' },
            'shield': { name: 'æŠ¤ç›¾', desc: 'å¢åŠ 50%é˜²å¾¡åŠ›ï¼ŒæŒç»­3å›åˆ', type: 'buff', power: 1.5, icon: 'ğŸ›¡ï¸' },
            'speed_up': { name: 'ç–¾é£', desc: 'æå‡30%æ•æ·', type: 'buff', power: 1.3, icon: 'ğŸ’¨' },
            'thunder': { name: 'è½é›·', desc: 'é€ æˆ180%é›·å±æ€§ä¼¤å®³', type: 'attack', power: 1.8, icon: 'âš¡' }
        };

        // æ½œåŠ›ç­‰çº§é…ç½®
        const POTENTIAL_LEVELS = ['å¹³åº¸', 'è¶…å¸¸', 'ç’€ç’¨'];

        // ç¨€æœ‰åº¦é…ç½®
        const RARITY_CONFIG = {
            // æ™®é€šç‰©ç§ 95%
            normal: {
                probability: 0.95,
                variants: [
                    { name: 'æ™®é€š', prefix: '', color: 0xcccccc, statMultiplier: 1.0 }
                ]
            },
            // ç¨€æœ‰åŒ– 5%
            rare: {
                probability: 0.05,
                variants: [
                    // é—ªå…‰ 80% of 5% = 4%
                    { name: 'é—ªå…‰', prefix: 'é—ªå…‰', color: 0xffd700, statMultiplier: 1.25, subProbability: 0.80 },
                    // å¹»å½© 15% of 5% = 0.75%
                    { name: 'å¹»å½©', prefix: 'å¹»å½©', color: 0xff69b4, statMultiplier: 1.5, subProbability: 0.15 },
                    // æ˜ŸèŠ’ 5% of 5% = 0.25%
                    { name: 'æ˜ŸèŠ’', prefix: 'æ˜ŸèŠ’', color: 0x9400d3, statMultiplier: 2.0, subProbability: 0.05 }
                ]
            }
        };

        // åˆ·æ–°é—´éš”ï¼ˆæ¯«ç§’ï¼‰
        const REFRESH_INTERVAL = 15000; // 15ç§’

        // --- Global Vars ---
        let scene, camera, renderer, worldGroup, raycaster, pointer;
        let gameState = {};
        let worldType = 'volcano'; // default
        let wildAnimals = [];
        let refreshTimer = null;
        let animalsInBattle = new Set(); // è®°å½•æ­£åœ¨æˆ˜æ–—çš„åŠ¨ç‰©ID
        let gltfLoader = null; // GLTFLoaderå®ä¾‹

        // --- UI Refs ---
        const ui = {
            modalOverlay: document.getElementById('modal-overlay'),
            animalDetailsPanel: document.getElementById('animal-details-panel'),
            btnCloseAnimalDetails: document.getElementById('btn-close-animal-details'),
            btnChallengeAnimal: document.getElementById('btn-challenge-animal'),
            battleSetupPanel: document.getElementById('battle-setup-panel'),
            btnCloseBattleSetupPanel: document.getElementById('btn-close-battle-setup-panel'),
            battleOpponentInfo: document.getElementById('battle-opponent-info'),
            battleTeamSelectionList: document.getElementById('battle-team-selection-list'),
            btnExecuteBattle: document.getElementById('btn-execute-battle'),
        };

        // --- Init ---
        window.onload = () => {
            const urlParams = new URLSearchParams(window.location.search);
            worldType = urlParams.get('world') || 'volcano';

            loadGameState();
            
            // æ£€æŸ¥æ˜¯å¦æœ‰åœ°å›¾é…ç½®
            const mapConfig = getCurrentMapConfig();
            if (mapConfig) {
                console.log('ä½¿ç”¨åœ°å›¾é…ç½®:', mapConfig.name);
            } else {
                console.log('ä½¿ç”¨é»˜è®¤é…ç½®:', worldType);
            }
            
            initThreeJS();
            setupEventListeners();
            populateWorld();
            processCapturedAnimal();
            startRefreshTimer();
        };

        function loadGameState() {
            const stateJSON = localStorage.getItem('gameState');
            if (stateJSON) {
                gameState = JSON.parse(stateJSON);
            } else {
                alert("æ•°æ®åŠ è½½å¤±è´¥ï¼Œè¿”å›ä¸»é¡µã€‚");
                window.location.href = 'game3d.html';
            }
        }

        function setupEventListeners() {
            document.getElementById('btn-return-map').addEventListener('click', () => {
                localStorage.setItem('gameState', JSON.stringify(gameState));
                window.location.href = 'world_map.html';
            });
            ui.btnCloseAnimalDetails.addEventListener('click', closeAnimalDetails);
            ui.btnChallengeAnimal.addEventListener('click', () => {
                const animalId = ui.btnChallengeAnimal.dataset.animalId;
                if (animalId) {
                    closeAnimalDetails();
                    openBattleSetupPanel(animalId);
                }
            });
            ui.btnCloseBattleSetupPanel.addEventListener('click', closeBattleSetupPanel);
            ui.btnExecuteBattle.addEventListener('click', startCombat);
            
            window.addEventListener('resize', onWindowResize, false);
            document.getElementById('container').addEventListener('mousedown', onPointerDown, false);
        }

        // --- 3D Scene ---
        function initThreeJS() {
            const mapConfig = getCurrentMapConfig();
            const config = mapConfig || WORLD_CONFIG[worldType];
            
            // ä½¿ç”¨åœ°å›¾é…ç½®æˆ–é»˜è®¤é…ç½®
            const mapName = mapConfig ? mapConfig.name : config.name;
            const groundColor = mapConfig ? 0x556b2f : config.groundColor; // åœ°å›¾é…ç½®æš‚æ—¶ä½¿ç”¨é»˜è®¤é¢œè‰²
            
            document.getElementById('world-name').textContent = mapName;

            scene = new THREE.Scene();
            scene.background = new THREE.Color(groundColor).multiplyScalar(0.5);
            scene.fog = new THREE.Fog(scene.background, 20, 60);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 10, 20);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('container').appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xcccccc, 1.5);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 2);
            directionalLight.position.set(10, 20, 5);
            scene.add(directionalLight);

            worldGroup = new THREE.Group();
            scene.add(worldGroup);

            const groundGeo = new THREE.PlaneGeometry(100, 100);
            const groundMat = new THREE.MeshLambertMaterial({ color: groundColor });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.userData.isGround = true;
            worldGroup.add(ground);

            raycaster = new THREE.Raycaster();
            pointer = new THREE.Vector2();

            // åˆå§‹åŒ–GLTFLoader
            const initGLTFLoader = () => {
                if (typeof THREE !== 'undefined' && THREE.GLTFLoader) {
                    gltfLoader = new THREE.GLTFLoader();
                    console.log('âœ… GLTFLoaderå·²åˆå§‹åŒ–');
                } else {
                    console.log('â³ ç­‰å¾…GLTFLoaderåŠ è½½...');
                    setTimeout(initGLTFLoader, 100);
                }
            };
            initGLTFLoader();

            animate();
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onPointerDown(event) {
            const clientX = event.clientX;
            const clientY = event.clientY;
            const rect = renderer.domElement.getBoundingClientRect();
            pointer.x = ((clientX - rect.left) / rect.width) * 2 - 1;
            pointer.y = -((clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(pointer, camera);
            const animalMeshes = wildAnimals.map(a => a.mesh);
            const intersects = raycaster.intersectObjects(animalMeshes);

            if (intersects.length > 0) {
                const clickedObject = intersects[0].object;
                if (clickedObject.userData.animalId) {
                    showAnimalDetails(clickedObject.userData.animalId);
                }
            } else if (event.target === renderer.domElement) {
                // ç‚¹å‡»ç©ºç™½å¤„å…³é—­è¯¦æƒ…é¢æ¿
                closeAnimalDetails();
            }
        }
        
        // æ–°å¢ï¼šæ˜¾ç¤ºåŠ¨ç‰©è¯¦æƒ…
        function showAnimalDetails(animalId) {
            const animal = wildAnimals.find(a => a.id === animalId);
            if (!animal) return;
            
            // å¡«å……åŸºç¡€æ•°æ®
            document.getElementById('detail-animal-name').textContent = animal.name;
            document.getElementById('detail-animal-level').textContent = `Lv. ${animal.level}`;
            document.getElementById('detail-animal-gender').textContent = animal.gender || 'æœªçŸ¥';
            document.getElementById('detail-animal-gender').className = animal.gender === 'é›„'
                ? 'text-sm font-normal px-2 py-1 rounded bg-blue-500'
                : 'text-sm font-normal px-2 py-1 rounded bg-pink-500';
            
            // å¡«å……ç»éªŒè¿›åº¦æ¡
            const expPercent = animal.experienceToNextLevel ? (animal.experience / animal.experienceToNextLevel) * 100 : 0;
            document.getElementById('detail-animal-exp-text').textContent = `${Math.floor(animal.experience || 0)} / ${animal.experienceToNextLevel || 100}`;
            document.getElementById('detail-animal-exp-bar').style.width = `${expPercent}%`;
            
            // å¡«å……å±æ€§é¢æ¿
            const rarityElement = document.getElementById('detail-animal-rarity');
            const rarityName = animal.rarity || 'æ™®é€š';
            const rarityColors = {
                'æ™®é€š': 'text-gray-400',
                'é—ªå…‰': 'text-yellow-400',
                'å¹»å½©': 'text-pink-400',
                'æ˜ŸèŠ’': 'text-purple-500'
            };
            rarityElement.textContent = rarityName;
            rarityElement.className = `font-mono font-bold ${rarityColors[rarityName] || 'text-gray-400'}`;
            
            document.getElementById('detail-animal-stamina').textContent = `${Math.floor(animal.stamina)} / ${animal.maxStamina || animal.stamina}`;
            document.getElementById('detail-animal-potential').textContent = animal.potential || 'å¹³åº¸';
            document.getElementById('detail-animal-element').textContent = animal.element;
            
            // å¡«å……èƒ½åŠ›é¢æ¿
            document.getElementById('detail-ability-combat-atk').textContent = animal.abilities.combat.attack;
            document.getElementById('detail-ability-combat-def').textContent = animal.abilities.combat.defense;
            document.getElementById('detail-ability-combat-agi').textContent = animal.abilities.combat.agility;
            
            // æ¸²æŸ“æˆ˜æ–—æŠ€èƒ½æ§½ä½
            renderCombatSkills(animal);
            
            // ä¿å­˜åŠ¨ç‰©IDåˆ°æŒ‘æˆ˜æŒ‰é’®
            ui.btnChallengeAnimal.dataset.animalId = animalId;
            
            // å®šä½é¢æ¿åˆ°åŠ¨ç‰©æ—è¾¹
            positionDetailPanelNearAnimal(animal);
            
            // æ˜¾ç¤ºé¢æ¿
            ui.animalDetailsPanel.classList.remove('hidden');
        }
        
        // æ–°å¢ï¼šæ¸²æŸ“æˆ˜æ–—æŠ€èƒ½æ§½ä½
        function renderCombatSkills(animal) {
            const skillsContainer = document.getElementById('detail-combat-skills');
            skillsContainer.innerHTML = '';
            
            // ç¡®ä¿åŠ¨ç‰©æœ‰æŠ€èƒ½æ•°ç»„
            const skills = animal.combatSkills || [null, null, null, null];
            
            // æ¸²æŸ“4ä¸ªæŠ€èƒ½æ§½ä½
            for (let i = 0; i < 4; i++) {
                const skillKey = skills[i];
                const skill = skillKey ? COMBAT_SKILLS[skillKey] : null;
                
                const slot = document.createElement('div');
                slot.className = 'h-12 w-12 bg-gray-800 border border-gray-600 rounded flex flex-col items-center justify-center text-xs cursor-pointer hover:bg-gray-700 transition-colors relative group';
                
                if (skill) {
                    slot.innerHTML = `
                        <div class="text-lg">${skill.icon}</div>
                        <div class="absolute bottom-full mb-2 hidden group-hover:block w-32 bg-black text-white text-xs rounded p-2 z-10 text-center shadow-lg">
                            <div class="font-bold">${skill.name}</div>
                            <div class="text-gray-300 mt-1">${skill.desc}</div>
                        </div>
                    `;
                } else {
                    slot.textContent = '+';
                    slot.title = 'ç©ºæŠ€èƒ½æ§½';
                }
                
                skillsContainer.appendChild(slot);
            }
        }
        
        // æ–°å¢ï¼šå…³é—­åŠ¨ç‰©è¯¦æƒ…
        function closeAnimalDetails() {
            ui.animalDetailsPanel.classList.add('hidden');
        }
        
        // æ–°å¢ï¼šå°†è¯¦æƒ…é¢æ¿å®šä½åˆ°åŠ¨ç‰©æ—è¾¹
        function positionDetailPanelNearAnimal(animal) {
            if (!animal || !animal.mesh) return;
            
            const panel = ui.animalDetailsPanel;
            const mesh = animal.mesh;
            
            // è·å–åŠ¨ç‰©åœ¨å±å¹•ä¸Šçš„2Dä½ç½®
            const vector = new THREE.Vector3();
            mesh.getWorldPosition(vector);
            vector.project(camera);
            
            // è½¬æ¢ä¸ºå±å¹•åæ ‡
            const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
            const y = (vector.y * -0.5 + 0.5) * window.innerHeight;
            
            // é¢æ¿å°ºå¯¸
            const panelWidth = 384; // w-96
            const panelHeight = 400;
            
            // è®¡ç®—ä½ç½®ï¼ˆä¼˜å…ˆå³ä¾§ï¼‰
            let left = x + 50;
            let top = y - panelHeight / 2;
            
            // è¾¹ç•Œæ£€æŸ¥
            if (left + panelWidth > window.innerWidth - 20) {
                left = x - panelWidth - 50;
            }
            if (left < 20) left = 20;
            if (top < 20) top = 20;
            if (top + panelHeight > window.innerHeight - 20) {
                top = window.innerHeight - panelHeight - 20;
            }
            
            // åº”ç”¨ä½ç½®
            panel.style.left = `${left}px`;
            panel.style.top = `${top}px`;
            panel.style.transform = 'none';
        }

        // --- Game Logic ---
        function populateWorld() {
            const mapConfig = getCurrentMapConfig();
            const config = mapConfig || WORLD_CONFIG[worldType];
            const maxAnimals = mapConfig ? mapConfig.maxAnimals : config.maxAnimals;
            const initialCount = Math.min(3, maxAnimals); // åˆå§‹ç”Ÿæˆ3åª
            
            for (let i = 0; i < initialCount; i++) {
                spawnAnimal();
            }
        }

        // ç”Ÿæˆéšæœºç¨€æœ‰åº¦
        function getRandomRarity() {
            const rand = Math.random();
            
            if (rand < 0.95) {
                // 95% æ¦‚ç‡ä¸ºæ™®é€š
                return { rarityKey: 'normal', ...RARITY_CONFIG.normal.variants[0] };
            } else {
                // 5% æ¦‚ç‡ä¸ºç¨€æœ‰åŒ–ï¼Œéœ€è¦è¿›ä¸€æ­¥ç»†åˆ†
                const rareRoll = Math.random();
                let cumulative = 0;
                
                for (const variant of RARITY_CONFIG.rare.variants) {
                    cumulative += variant.subProbability;
                    if (rareRoll <= cumulative) {
                        return { rarityKey: 'rare', ...variant };
                    }
                }
                
                // é»˜è®¤è¿”å›é—ªå…‰ï¼ˆä¸åº”è¯¥åˆ°è¿™é‡Œï¼‰
                return { rarityKey: 'rare', ...RARITY_CONFIG.rare.variants[0] };
            }
        }

        // ç”Ÿæˆä¸€åªæ–°åŠ¨ç‰©
        function spawnAnimal() {
            const mapConfig = getCurrentMapConfig();
            const config = mapConfig || WORLD_CONFIG[worldType];
            const maxAnimals = mapConfig ? mapConfig.maxAnimals : config.maxAnimals;
            
            if (wildAnimals.length >= maxAnimals) return;
            
            // ä½¿ç”¨åœ°å›¾é…ç½®ç”ŸæˆåŠ¨ç‰©
            let animalData;
            if (mapConfig) {
                // å¦‚æœæœ‰åœ°å›¾é…ç½®ï¼Œå¿…é¡»ä»é…ç½®ä¸­ç”Ÿæˆ
                animalData = createAnimalFromMapConfig(mapConfig);
                if (!animalData) {
                    console.warn('åœ°å›¾é…ç½®ä¸­æ²¡æœ‰å¯ç”¨çš„åŠ¨ç‰©æ¨¡æ¿');
                    return; // å¦‚æœæ²¡æœ‰æ¨¡æ¿ï¼Œä¸ç”ŸæˆåŠ¨ç‰©
                }
            } else {
                // æ²¡æœ‰åœ°å›¾é…ç½®æ—¶ä½¿ç”¨é»˜è®¤ç”Ÿæˆ
                animalData = createWildAnimal(config.animalElement);
            }
            
            const angle = Math.random() * Math.PI * 2;
            const radius = 5 + Math.random() * 15;
            animalData.mesh.position.set(Math.cos(angle) * radius, 1, Math.sin(angle) * radius);
            worldGroup.add(animalData.mesh);
            wildAnimals.push(animalData);
        }
        
        // ä»åœ°å›¾é…ç½®ç”ŸæˆåŠ¨ç‰©
        function createAnimalFromMapConfig(mapConfig) {
            // æ£€æŸ¥åœ°å›¾æ˜¯å¦é…ç½®äº†åŠ¨ç‰©
            if (!mapConfig.animals || mapConfig.animals.length === 0) {
                console.warn('åœ°å›¾æœªé…ç½®åŠ¨ç‰©');
                return null;
            }
            
            // 1. æ ¹æ®æƒé‡é€‰æ‹©ä¸€ä¸ªåŠ¨ç‰©é…ç½®ï¼ˆå¯èƒ½æ˜¯ç»„ä¸­çš„æŸä¸ªç¨€æœ‰åº¦å˜ä½“ï¼‰
            const selectedConfig = selectAnimalConfigByWeight(mapConfig.animals);
            
            if (!selectedConfig) {
                console.warn('æœªæ‰¾åˆ°å¯ç”¨çš„åŠ¨ç‰©é…ç½®');
                return null;
            }
            
            // 2. ç¡®å®šä½¿ç”¨å“ªä¸ªæ¨¡æ¿
            let templateKey = selectedConfig.animalKey;
            
            // å¦‚æœè¯¥ç¨€æœ‰åº¦å˜ä½“é…ç½®äº†è‡ªå®šä¹‰æ¨¡æ¿ï¼Œä½¿ç”¨è‡ªå®šä¹‰æ¨¡æ¿
            if (selectedConfig.selectedAnimalKey) {
                templateKey = selectedConfig.selectedAnimalKey;
            }
            
            const template = animalPool.find(a => a.key === templateKey);
            
            if (!template) {
                console.warn('æœªæ‰¾åˆ°åŠ¨ç‰©æ¨¡æ¿:', templateKey);
                return null;
            }
            
            // 3. æ ¹æ®æ½œåŠ›æ¯”ä¾‹å†³å®šæˆé•¿ç±»å‹
            const growthType = rollGrowthType(selectedConfig.growthRatios);
            
            // 4. åŸºäºæ¨¡æ¿å’Œé…ç½®åˆ›å»ºåŠ¨ç‰©å®ä¾‹
            return createAnimalFromTemplate(template, selectedConfig.rarityType, growthType, selectedConfig);
        }
        
        // æ ¹æ®æƒé‡é€‰æ‹©åŠ¨ç‰©é…ç½®
        function selectAnimalConfigByWeight(animalConfigs) {
            if (!animalConfigs || animalConfigs.length === 0) return null;
            
            // è®¡ç®—æ€»æƒé‡
            const totalWeight = animalConfigs.reduce((sum, config) => sum + (config.weight || 0), 0);
            
            if (totalWeight <= 0) return animalConfigs[0]; // å¦‚æœæ²¡æœ‰æƒé‡ï¼Œè¿”å›ç¬¬ä¸€ä¸ª
            
            // æ ¹æ®æƒé‡éšæœºé€‰æ‹©
            let random = Math.random() * totalWeight;
            
            for (const config of animalConfigs) {
                random -= (config.weight || 0);
                if (random <= 0) return config;
            }
            
            return animalConfigs[0];
        }
        
        // æ ¹æ®æ½œåŠ›æ¯”ä¾‹æŠ½å–æˆé•¿ç±»å‹
        function rollGrowthType(growthRatios) {
            if (!growthRatios) return 'mediocre';
            
            const rand = Math.random() * 100;
            let cumulative = 0;
            
            const types = ['mediocre', 'extraordinary', 'brilliant'];
            for (const type of types) {
                cumulative += parseFloat(growthRatios[type] || 0);
                if (rand <= cumulative) {
                    return type;
                }
            }
            
            return 'mediocre';
        }
        
        // Base64è½¬ArrayBuffer
        function base64ToArrayBuffer(base64) {
            const binaryString = atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes.buffer;
        }
        
        // åº”ç”¨é¢œè‰²åˆ°æ¨¡å‹
        function applyColorToModel(model, colorHex) {
            const color = new THREE.Color(colorHex);
            model.traverse((child) => {
                if (child.isMesh && child.material) {
                    if (Array.isArray(child.material)) {
                        child.material.forEach(mat => {
                            if (mat.color) mat.color.set(color);
                        });
                    } else {
                        if (child.material.color) {
                            child.material.color.set(color);
                        }
                    }
                }
            });
        }
        
        // åŸºäºæ¨¡æ¿åˆ›å»ºåŠ¨ç‰©å®ä¾‹
        function createAnimalFromTemplate(template, rarityType, growthType, config) {
            const id = crypto.randomUUID();
            
            // ç¨€æœ‰åº¦é¢œè‰²æ˜ å°„
            const rarityColors = {
                'common': parseInt(template.color.replace('#', ''), 16),
                'shiny': 0xffd700,
                'prismatic': 0xff69b4,
                'stellar': 0x9400d3
            };
            
            const rarityNames = {
                'common': 'æ™®é€š',
                'shiny': 'é—ªå…‰',
                'prismatic': 'å¹»å½©',
                'stellar': 'æ˜ŸèŠ’'
            };
            
            const rarityMultipliers = {
                'common': 1.0,
                'shiny': 1.25,
                'prismatic': 1.5,
                'stellar': 2.0
            };
            
            const growthNames = {
                'mediocre': 'å¹³åº¸',
                'extraordinary': 'è¶…å¸¸',
                'brilliant': 'ç’€ç’¨'
            };
            
            const color = rarityColors[rarityType] || rarityColors['common'];
            const rarityName = rarityNames[rarityType] || 'æ™®é€š';
            const multiplier = rarityMultipliers[rarityType] || 1.0;
            const growthName = growthNames[growthType] || 'å¹³åº¸';
            
            // åˆ›å»º3Dæ¨¡å‹ - æ”¯æŒGLBæ¨¡å‹
            let mesh = null;
            const animalData = {
                id: id,
                animalId: template.animalId,  // è®¾ç½®ç‰©ç§IDï¼ˆé‡è¦ï¼ï¼‰
                name: template.name,
                level: template.level || 1,
                gender: Math.random() > 0.5 ? 'é›„' : 'é›Œ',
                element: template.element || 'æœªçŸ¥',
                rarity: rarityName,
                rarityKey: rarityType,
                experience: 0,
                experienceToNextLevel: template.baseExp || 100,
                stamina: Math.floor((template.stamina || 100) * multiplier),
                maxStamina: Math.floor((template.stamina || 100) * multiplier),
                health: Math.floor((template.health || 100) * multiplier),
                maxHealth: Math.floor((template.health || 100) * multiplier),
                potential: growthName,
                growthType: growthType,
                color: color,
                isWild: true,
                abilities: {
                    combat: {
                        attack: Math.floor((template.attack || 10) * multiplier),
                        defense: Math.floor((template.defense || 5) * multiplier),
                        agility: Math.floor((template.agility || 8) * multiplier)
                    }
                },
                combatSkills: [],
                templateKey: template.key,
                configKey: config ? `${config.animalKey}_${config.rarityType}` : null,
                mesh: null // ç¨åè®¾ç½®
            };
            
            // å¤„ç†æŠ€èƒ½
            if (template.skills && template.skills.length > 0) {
                const unlockedSkills = template.skills.filter(s => s.unlockLevel <= animalData.level);
                animalData.combatSkills = unlockedSkills.map(s => s.skillKey);
            }
            
            // æ£€æŸ¥æ˜¯å¦æœ‰è‡ªå®šä¹‰GLBæ¨¡å‹
            if (template.modelData && template.modelShape === 'custom') {
                console.log('ğŸ”„ åŠ è½½è‡ªå®šä¹‰GLBæ¨¡å‹:', template.name);
                
                // åˆ›å»ºä¸€ä¸ªä¸´æ—¶çš„å ä½ç¬¦
                const tempGeometry = new THREE.SphereGeometry(1, 16, 16);
                const tempMaterial = new THREE.MeshPhongMaterial({ color: color });
                mesh = new THREE.Mesh(tempGeometry, tempMaterial);
                mesh.userData.animalId = id;
                animalData.mesh = mesh;
                
                // å¼‚æ­¥åŠ è½½GLBæ¨¡å‹
                loadGLBModelForAnimal(template.modelData, color, (loadedModel) => {
                    if (loadedModel && animalData.mesh) {
                        // æ›¿æ¢ä¸´æ—¶æ¨¡å‹
                        const oldMesh = animalData.mesh;
                        const position = oldMesh.position.clone();
                        
                        // ä»åœºæ™¯ä¸­ç§»é™¤æ—§æ¨¡å‹
                        worldGroup.remove(oldMesh);
                        oldMesh.geometry.dispose();
                        oldMesh.material.dispose();
                        
                        // æ·»åŠ æ–°æ¨¡å‹
                        loadedModel.position.copy(position);
                        loadedModel.userData.animalId = id;
                        animalData.mesh = loadedModel;
                        worldGroup.add(loadedModel);
                        
                        console.log('âœ… GLBæ¨¡å‹åŠ è½½æˆåŠŸ:', template.name);
                    }
                });
            } else {
                // ä½¿ç”¨é»˜è®¤å‡ ä½•ä½“
                const shape = template.modelShape || 'sphere';
                let geometry;
                
                switch(shape) {
                    case 'cube':
                        geometry = new THREE.BoxGeometry(1.5, 1.5, 1.5);
                        break;
                    case 'cone':
                        geometry = new THREE.ConeGeometry(0.8, 1.8, 32);
                        break;
                    case 'torus':
                        geometry = new THREE.TorusGeometry(0.8, 0.3, 16, 100);
                        break;
                    case 'octahedron':
                        geometry = new THREE.OctahedronGeometry(1.2, 0);
                        break;
                    case 'sphere':
                    default:
                        geometry = new THREE.SphereGeometry(1, 16, 16);
                        break;
                }
                
                const material = new THREE.MeshPhongMaterial({ color: color });
                mesh = new THREE.Mesh(geometry, material);
                mesh.userData.animalId = id;
                animalData.mesh = mesh;
            }
            
            return animalData;
        }
        
        // åŠ è½½GLBæ¨¡å‹
        function loadGLBModelForAnimal(base64Data, colorHex, callback) {
            if (!gltfLoader) {
                console.error('âŒ GLTFLoaderæœªåˆå§‹åŒ–');
                callback(null);
                return;
            }
            
            try {
                const arrayBuffer = base64ToArrayBuffer(base64Data);
                
                gltfLoader.parse(arrayBuffer, '',
                    function(gltf) {
                        const model = gltf.scene;
                        
                        // è°ƒæ•´æ¨¡å‹å¤§å°
                        const box = new THREE.Box3().setFromObject(model);
                        const size = box.getSize(new THREE.Vector3());
                        const maxDim = Math.max(size.x, size.y, size.z);
                        
                        if (maxDim > 0) {
                            const scale = 2 / maxDim;
                            model.scale.setScalar(scale);
                        }
                        
                        // å±…ä¸­æ¨¡å‹
                        const center = box.getCenter(new THREE.Vector3());
                        model.position.sub(center.multiplyScalar(model.scale.x));
                        
                        // åº”ç”¨é¢œè‰²
                        applyColorToModel(model, colorHex);
                        
                        callback(model);
                    },
                    function(error) {
                        console.error('âŒ GLBæ¨¡å‹åŠ è½½å¤±è´¥:', error);
                        callback(null);
                    }
                );
            } catch (error) {
                console.error('âŒ GLBæ¨¡å‹è§£æå¼‚å¸¸:', error);
                callback(null);
            }
        }

        // åˆ·æ–°åŠ¨ç‰©
        function refreshAnimals() {
            const mapConfig = getCurrentMapConfig();
            const config = mapConfig || WORLD_CONFIG[worldType];
            const maxAnimals = mapConfig ? mapConfig.maxAnimals : config.maxAnimals;
            
            // ç§»é™¤æœªåœ¨æˆ˜æ–—ä¸­çš„åŠ¨ç‰©
            const animalsToRemove = wildAnimals.filter(a => !animalsInBattle.has(a.id));
            animalsToRemove.forEach(animal => {
                worldGroup.remove(animal.mesh);
                const index = wildAnimals.indexOf(animal);
                if (index > -1) {
                    wildAnimals.splice(index, 1);
                }
            });
            
            // ç”Ÿæˆæ–°åŠ¨ç‰©ç›´åˆ°è¾¾åˆ°æœ€å¤§æ•°é‡
            while (wildAnimals.length < maxAnimals) {
                spawnAnimal();
            }
        }

        // å¯åŠ¨åˆ·æ–°å®šæ—¶å™¨
        function startRefreshTimer() {
            refreshTimer = setInterval(refreshAnimals, REFRESH_INTERVAL);
        }

        function createWildAnimal(element) {
            const id = crypto.randomUUID();
            
            // è·å–éšæœºç¨€æœ‰åº¦
            const rarity = getRandomRarity();
            
            const geometry = new THREE.SphereGeometry(1, 16, 16);
            const material = new THREE.MeshPhongMaterial({ color: rarity.color });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.userData.animalId = id;
            
            // æ ¹æ®å…ƒç´ ç±»å‹ç”Ÿæˆå¯¹åº”çš„æˆ˜æ–—æŠ€èƒ½
            const elementSkillMapping = {
                'ç«': ['fireball', 'strike'],
                'æ°´': ['heal', 'shield'],
                'é£': ['speed_up', 'strike'],
                'æœ¨': ['heal', 'shield']
            };
            
            // éšæœºé€‰æ‹©1-2ä¸ªæŠ€èƒ½
            const availableSkillKeys = elementSkillMapping[element] || ['strike'];
            const skillCount = Math.random() > 0.5 ? 2 : 1;
            const combatSkills = availableSkillKeys.slice(0, skillCount);
            
            const baseLevel = Math.floor(Math.random() * 5) + 1;
            const level = Math.floor(baseLevel * rarity.statMultiplier);
            const baseStamina = 50 + Math.floor(Math.random() * 20);
            const stamina = Math.floor(baseStamina * rarity.statMultiplier);
            
            // åŸºç¡€å±æ€§
            const baseAttack = 10 + Math.floor(Math.random() * 5);
            const baseDefense = 5 + Math.floor(Math.random() * 3);
            const baseAgility = 8 + Math.floor(Math.random() * 4);

            return {
                id: id,
                animalId: null,  // é»˜è®¤ç”Ÿæˆçš„åŠ¨ç‰©æ²¡æœ‰ç‰©ç§IDï¼ˆå› ä¸ºä¸æ˜¯åŸºäºæ¨¡æ¿ï¼‰
                name: rarity.prefix ? `${rarity.prefix}Â·é‡ç”Ÿ${element}å…½` : `é‡ç”Ÿ${element}å…½`,
                level: level,
                gender: Math.random() > 0.5 ? 'é›„' : 'é›Œ',
                element: element,
                rarity: rarity.name,
                rarityKey: rarity.rarityKey,
                experience: 0,
                experienceToNextLevel: 100,
                stamina: stamina,
                maxStamina: stamina,
                potential: POTENTIAL_LEVELS[Math.floor(Math.random() * POTENTIAL_LEVELS.length)],
                color: rarity.color,
                isWild: true,
                abilities: {
                    combat: {
                        attack: Math.floor(baseAttack * rarity.statMultiplier),
                        defense: Math.floor(baseDefense * rarity.statMultiplier),
                        agility: Math.floor(baseAgility * rarity.statMultiplier)
                    }
                },
                combatSkills: combatSkills,
                mesh: mesh
            };
        }
        
        // --- Combat Logic (Copied & adapted from game3d.html) ---
        function openBattleSetupPanel(wildAnimalId) {
            closeAnimalDetails(); // å…³é—­è¯¦æƒ…é¢æ¿
            const opponent = wildAnimals.find(a => a.id === wildAnimalId);
            if (!opponent) return;

            // æ ‡è®°è¯¥åŠ¨ç‰©æ­£åœ¨æˆ˜æ–—
            animalsInBattle.add(wildAnimalId);
            
            gameState.battle = { opponent: opponent, playerAnimal: null };

            ui.battleOpponentInfo.innerHTML = `
                <div class="flex items-center space-x-3">
                    <div style="background-color: #${opponent.color.toString(16).padStart(6, '0')};" class="w-5 h-5 rounded-full border-2 border-red-400"></div>
                    <span class="font-bold text-red-400">${opponent.name}</span>
                </div>
                <span class="text-sm font-mono text-yellow-400">Lv. ${opponent.level}</span>
            `;

            renderBattleSelectionList();
            ui.btnExecuteBattle.disabled = true;
            ui.modalOverlay.classList.remove('hidden');
            ui.battleSetupPanel.classList.remove('hidden');
        }

        function closeBattleSetupPanel() {
            ui.battleSetupPanel.classList.add('hidden');
            ui.modalOverlay.classList.add('hidden');
            gameState.battle = null;
        }

        function renderBattleSelectionList() {
            const listElement = ui.battleTeamSelectionList;
            listElement.innerHTML = '';
            const availableAnimals = gameState.animals.filter(a => !a.isPlaced && !a.isInjured);

            if (availableAnimals.length === 0) {
                listElement.innerHTML = '<p class="text-sm text-gray-500 p-2">æ²¡æœ‰ç©ºé—²ä¸”å¥åº·çš„åŠ¨ç‰©å¯å‡ºæˆ˜ã€‚</p>';
                return;
            }

            availableAnimals.forEach(animal => {
                const isSelected = gameState.battle && gameState.battle.playerAnimal && gameState.battle.playerAnimal.id === animal.id;
                const listItem = document.createElement('div');
                listItem.className = `flex items-center justify-between p-2 rounded-md hover:bg-gray-700 cursor-pointer ${isSelected ? 'bg-blue-800' : ''}`;
                listItem.innerHTML = `
                    <span class="font-medium text-indigo-300">${animal.name}</span>
                    <span class="text-sm text-yellow-400">Lv. ${animal.level}</span>`;
                listItem.onclick = () => selectAnimalForCombat(animal.id);
                listElement.appendChild(listItem);
            });
        }

        function selectAnimalForCombat(animalId) {
            if (!gameState.battle) return;
            gameState.battle.playerAnimal = gameState.animals.find(a => a.id === animalId);
            ui.btnExecuteBattle.disabled = false;
            renderBattleSelectionList();
        }

        function startCombat() {
            if (!gameState.battle) return;
            const { opponent, playerAnimal } = gameState.battle;
            if (!opponent || !playerAnimal) return;

            const getSerializableAnimal = (animal) => {
                const serializableAnimal = { ...animal };
                delete serializableAnimal.mesh;
                return serializableAnimal;
            };

            // æ ‡è®°åŠ¨ç‰©è¿›å…¥æˆ˜æ–—
            animalsInBattle.add(opponent.id);
            
            localStorage.setItem('battleOpponent', JSON.stringify(getSerializableAnimal(opponent)));
            localStorage.setItem('battlePlayerAnimal', JSON.stringify(getSerializableAnimal(playerAnimal)));
            localStorage.setItem('battleReturnUrl', window.location.href);
            window.location.href = 'battle.html';
        }
        
        function processCapturedAnimal() {
            const capturedAnimalDataJSON = localStorage.getItem('capturedAnimal');
            if (!capturedAnimalDataJSON) return;

            const capturedAnimalData = JSON.parse(capturedAnimalDataJSON);

            const wildAnimalIndex = wildAnimals.findIndex(a => a.id === capturedAnimalData.id);
            if (wildAnimalIndex > -1) {
                const originalWildAnimal = wildAnimals[wildAnimalIndex];
                worldGroup.remove(originalWildAnimal.mesh);
                wildAnimals.splice(wildAnimalIndex, 1);

                // ä¿®å¤ï¼šè½¬æ¢ combatSkills æ•°æ®ç»“æ„ä»¥åŒ¹é… animal_management.html çš„æœŸæœ›æ ¼å¼
                capturedAnimalData.isWild = false;
                capturedAnimalData.isPlaced = false;
                
                // å°†ç®€å•æ•°ç»„æ ¼å¼è½¬æ¢ä¸ºå¯¹è±¡æ ¼å¼
                if (Array.isArray(capturedAnimalData.combatSkills)) {
                    const skillsArray = capturedAnimalData.combatSkills;
                    capturedAnimalData.combatSkills = {
                        equipped: skillsArray.slice(0, 4), // æœ€å¤š4ä¸ªè£…å¤‡æ§½
                        available: skillsArray // æ‰€æœ‰æŠ€èƒ½éƒ½å¯ç”¨
                    };
                }
                
                // ç¡®ä¿æœ‰å®Œæ•´çš„æ•°æ®ç»“æ„
                if (!capturedAnimalData.combatSkills) {
                    capturedAnimalData.combatSkills = { equipped: [], available: [] };
                }
                
                // ä¿®å¤ï¼šå°†ç¨€æœ‰åº¦æ˜ å°„åˆ°å˜å¼‚ç³»ç»Ÿ
                if (!capturedAnimalData.mutations) {
                    capturedAnimalData.mutations = { tier1: null, tier2: null, skills: [], history: [] };
                }
                
                // ç¨€æœ‰åŒ–åŠ¨ç‰©ä¸æ˜ å°„åˆ°å˜å¼‚ç³»ç»Ÿï¼Œä¿æŒå…¶ç¨€æœ‰åº¦ä½œä¸ºç‹¬ç«‹å±æ€§
                // ç¨€æœ‰åŒ–ï¼ˆé—ªå…‰ã€å¹»å½©ã€æ˜ŸèŠ’ï¼‰åœ¨å˜å¼‚ç³»ç»Ÿä¸­ä¿æŒä¸å˜
                // åªéœ€è¦ç¡®ä¿ rarity å­—æ®µè¢«ä¿ç•™å³å¯
                
                // åˆå§‹åŒ–å˜å¼‚æ¬¡æ•°ï¼ˆå¦‚æœè¿˜æœªè®¾ç½®ï¼‰
                if (typeof capturedAnimalData.mutationCount === 'undefined') {
                    capturedAnimalData.mutationCount = 0;
                }
                
                // åˆå§‹åŒ–å¥½æ„Ÿåº¦
                if (typeof capturedAnimalData.favorability === 'undefined') {
                    capturedAnimalData.favorability = 0;
                }
                
                // åˆå§‹åŒ–å‘è‚²é˜¶æ®µ
                if (!capturedAnimalData.developmentStage) {
                    capturedAnimalData.developmentStage = 'å¹¼å¹´æœŸ';
                }
                
                // åˆå§‹åŒ–æ¨¡æ¿æŠ€èƒ½è§£é”è®°å½•
                if (!capturedAnimalData.templateSkillsUnlocked) {
                    capturedAnimalData.templateSkillsUnlocked = [];
                }
                
                // å¦‚æœæœ‰æ¨¡æ¿ï¼Œæ£€æŸ¥å½“å‰ç­‰çº§åº”è¯¥è§£é”çš„æ‰€æœ‰æŠ€èƒ½
                if (capturedAnimalData.templateKey) {
                    const animalPool = JSON.parse(localStorage.getItem('ANIMAL_POOL') || '[]');
                    const skillPool = JSON.parse(localStorage.getItem('SKILL_POOL') || '[]');
                    const template = animalPool.find(t => t.key === capturedAnimalData.templateKey);
                    
                    if (template && template.skills && template.skills.length > 0) {
                        // è§£é”æ‰€æœ‰ç­‰çº§ <= å½“å‰ç­‰çº§çš„æŠ€èƒ½
                        template.skills.forEach(skillConfig => {
                            if (skillConfig.unlockLevel <= capturedAnimalData.level) {
                                // æ£€æŸ¥æ˜¯å¦å·²ç»è§£é”è¿‡
                                if (capturedAnimalData.templateSkillsUnlocked.includes(skillConfig.skillKey)) {
                                    return; // å·²è§£é”ï¼Œè·³è¿‡
                                }
                                
                                // æŸ¥æ‰¾æŠ€èƒ½ä¿¡æ¯
                                const skill = skillPool.find(s => s.key === skillConfig.skillKey);
                                if (!skill) {
                                    console.warn('æŠ€èƒ½ä¸å­˜åœ¨:', skillConfig.skillKey);
                                    return;
                                }
                                
                                // è§£é”æŠ€èƒ½
                                capturedAnimalData.templateSkillsUnlocked.push(skillConfig.skillKey);
                                
                                // æ ¹æ®æŠ€èƒ½ç±»åˆ«æ·»åŠ åˆ°å¯¹åº”çš„æŠ€èƒ½åˆ—è¡¨
                                if (skill.category && skill.category.startsWith('mutation-')) {
                                    // å˜å¼‚æŠ€èƒ½
                                    if (!capturedAnimalData.mutations.skills.includes(skillConfig.skillKey)) {
                                        capturedAnimalData.mutations.skills.push(skillConfig.skillKey);
                                    }
                                } else {
                                    // æˆ˜æ–—æŠ€èƒ½
                                    if (!capturedAnimalData.combatSkills.available.includes(skillConfig.skillKey)) {
                                        capturedAnimalData.combatSkills.available.push(skillConfig.skillKey);
                                    }
                                }
                            }
                        });
                    }
                }
                
                delete capturedAnimalData.mesh;
                gameState.animals.push(capturedAnimalData);
                gameState.animalCount++;
                
                localStorage.setItem('gameState', JSON.stringify(gameState));
                localStorage.removeItem('capturedAnimal');
                alert(`æˆåŠŸæ•è· ${capturedAnimalData.name}ï¼å®ƒå·²è¢«ä¼ é€å›ä½ çš„ä¸»æ –æ¯åœ°ã€‚`);
            }
        }

    </script>
</body>
</html>